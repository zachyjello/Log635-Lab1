# Copyright (c) 2016-2017 Anki, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the file LICENSE.txt or at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Autogenerated python message buffer code.
Source: clad/types/needsSystemTypes.clad
Full command line: ../tools/message-buffers/emitters/Python_emitter.py -C ./src/ -I ../robot/clad/src/ ../coretech/vision/clad/src/ ../coretech/common/clad/src/ ../lib/util/source/anki/clad -o ../generated/cladPython// clad/types/needsSystemTypes.clad
"""

from __future__ import absolute_import
from __future__ import print_function

def _modify_path():
  import inspect, os, sys
  search_paths = [
    '../..',
    '../../../../tools/message-buffers/support/python',
  ]
  currentpath = os.path.abspath(os.path.dirname(inspect.getfile(inspect.currentframe())))
  for search_path in search_paths:
    search_path = os.path.normpath(os.path.abspath(os.path.realpath(os.path.join(currentpath, search_path))))
    if search_path not in sys.path:
      sys.path.insert(0, search_path)
_modify_path()

import msgbuffers

Anki = msgbuffers.Namespace()
Anki.Cozmo = msgbuffers.Namespace()
Anki.Util = msgbuffers.Namespace()
Anki.Util.AnkiLab = msgbuffers.Namespace()

from clad.types.unlockTypes import Anki as _Anki
Anki.update(_Anki.deep_clone())

from util.ankiLab.ankiLabDef import Anki as _Anki
Anki.update(_Anki.deep_clone())

class NeedId(object):
  "Automatically-generated int_32 enumeration."
  Repair = 0
  Energy = 1
  Play   = 2
  Count  = 3

Anki.Cozmo.NeedId = NeedId
del NeedId


class NeedBracketId(object):
  "Automatically-generated int_32 enumeration."
  Full     = 0
  Normal   = 1
  Warning  = 2
  Critical = 3
  Count    = 4

Anki.Cozmo.NeedBracketId = NeedBracketId
del NeedBracketId


def IsNeedBracketMet(needBracketId, defaultValue):
  return {
    NeedBracketId.Full: 1,
    NeedBracketId.Normal: 1,
    NeedBracketId.Warning: 0,
    NeedBracketId.Critical: 0,
    NeedBracketId.Count: 0,
    }.get(needBracketId, defaultValue)
Anki.Cozmo.IsNeedBracketMet = IsNeedBracketMet
del IsNeedBracketMet


class RepairablePartId(object):
  "Automatically-generated int_32 enumeration."
  Head   = 0
  Lift   = 1
  Treads = 2

Anki.Cozmo.RepairablePartId = RepairablePartId
del RepairablePartId


class NeedsActionId(object):
  "Automatically-generated int_32 enumeration."
  NoAction                    = 0
  Decay                       = 1
  RepairHead                  = 2
  RepairLift                  = 3
  RepairTreads                = 4
  Feed                        = 5
  KeepAwayWin                 = 6
  KeepAwayLose                = 7
  MemoryMatchWin              = 8
  MemoryMatchLose             = 9
  QuickTapWin                 = 10
  QuickTapLose                = 11
  CozmoPerformsComplete       = 12
  CozmoSings                  = 13
  DizzyHard                   = 14
  DizzyMedium                 = 15
  DizzySoft                   = 16
  Fall                        = 17
  FistBump                    = 18
  FistBump_Sparked            = 19
  GatherCubes                 = 20
  GuardDogLose                = 21
  GuardDogWin                 = 22
  GuardDogNoInteraction       = 23
  HiccupsEndBad               = 24
  HiccupsEndGood              = 25
  IndividualHiccup            = 26
  KnockDownCubes              = 27
  KnockDownCubes_Sparked      = 28
  PeekAboo                    = 29
  PeekAboo_Sparked            = 30
  PickupCube                  = 31
  PickupCube_Sparked          = 32
  PopAWheelie                 = 33
  PopAWheelie_Sparked         = 34
  Pounce                      = 35
  Pounce_Sparked              = 36
  PyramidCompleted            = 37
  PyramidCompleted_Sparked    = 38
  RollACube                   = 39
  RollACube_Sparked           = 40
  SayName                     = 41
  StackCube                   = 42
  StackCube_Sparked           = 43
  Workout                     = 44
  Workout_Sparked             = 45
  SeeFace                     = 46
  PlacedOnSide                = 47
  BoredOnSide                 = 48
  Laser_Sparked               = 49
  CubeMixup                   = 50
  TreasureTrail               = 51
  Roboshambo                  = 52
  TwistTapRoll                = 53
  CubeTennis                  = 54
  TidalTap                    = 55
  StareOff                    = 56
  DadJokesBadJokes            = 57
  CubeBlaster                 = 58
  NumberTap                   = 59
  JackpotBot                  = 60
  ColorShuffle                = 61
  ForYouMom                   = 62
  ComposeWithCozmo            = 63
  PoetryJam                   = 64
  CozmosGarden                = 65
  Constellations              = 66
  GuessTheNumber              = 67
  WakeUpCozmo                 = 68
  PaddleBall                  = 69
  DrivingInCircles            = 70
  PotOGoldDetector            = 71
  ComplimentGenerator         = 72
  RemoteControlRacer          = 73
  ShakeIt                     = 74
  PuttPutt                    = 75
  ValentinesCozmogram         = 76
  LaserSmile                  = 77
  MagicFortuneTeller          = 78
  LightShow                   = 79
  CubeWhack                   = 80
  TinyOrchestra               = 81
  HotPotato                   = 82
  BlasterTag                  = 83
  FireTruckAlarm              = 84
  CozmoSingsCompleted_Sparked = 85
  Count                       = 86

Anki.Cozmo.NeedsActionId = NeedsActionId
del NeedsActionId


class NeedsRewardType(object):
  "Automatically-generated int_32 enumeration."
  Sparks      = 0
  Unlock      = 1
  Song        = 2
  MemoryBadge = 3

Anki.Cozmo.NeedsRewardType = NeedsRewardType
del NeedsRewardType


class NeedsReward(object):
  "Generated message-passing structure."

  __slots__ = (
    '_rewardType',      # Anki.Cozmo.NeedsRewardType
    '_data',            # string[uint_8]
    '_inventoryIsFull', # bool
  )

  @property
  def rewardType(self):
    "Anki.Cozmo.NeedsRewardType rewardType struct property."
    return self._rewardType

  @rewardType.setter
  def rewardType(self, value):
    self._rewardType = msgbuffers.validate_integer(
      'NeedsReward.rewardType', value, -2147483648, 2147483647)

  @property
  def data(self):
    "string[uint_8] data struct property."
    return self._data

  @data.setter
  def data(self, value):
    self._data = msgbuffers.validate_string(
      'NeedsReward.data', value, 255)

  @property
  def inventoryIsFull(self):
    "bool inventoryIsFull struct property."
    return self._inventoryIsFull

  @inventoryIsFull.setter
  def inventoryIsFull(self, value):
    self._inventoryIsFull = msgbuffers.validate_bool(
      'NeedsReward.inventoryIsFull', value)

  def __init__(self, rewardType=Anki.Cozmo.NeedsRewardType.Sparks, data='', inventoryIsFull=False):
    self.rewardType = rewardType
    self.data = data
    self.inventoryIsFull = inventoryIsFull

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NeedsReward from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NeedsReward.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NeedsReward from the given BinaryReader."
    _rewardType = reader.read('i')
    _data = reader.read_string('B')
    _inventoryIsFull = bool(reader.read('b'))
    return cls(_rewardType, _data, _inventoryIsFull)

  def pack(self):
    "Writes the current NeedsReward, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NeedsReward to the given BinaryWriter."
    writer.write(self._rewardType, 'i')
    writer.write_string(self._data, 'B')
    writer.write(int(self._inventoryIsFull), 'b')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._rewardType == other._rewardType and
        self._data == other._data and
        self._inventoryIsFull == other._inventoryIsFull)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._rewardType, 'i') +
      msgbuffers.size_string(self._data, 'B') +
      msgbuffers.size(self._inventoryIsFull, 'b'))

  def __str__(self):
    return '{type}(rewardType={rewardType}, data={data}, inventoryIsFull={inventoryIsFull})'.format(
      type=type(self).__name__,
      rewardType=self._rewardType,
      data=msgbuffers.shorten_string(self._data),
      inventoryIsFull=self._inventoryIsFull)

  def __repr__(self):
    return '{type}(rewardType={rewardType}, data={data}, inventoryIsFull={inventoryIsFull})'.format(
      type=type(self).__name__,
      rewardType=repr(self._rewardType),
      data=repr(self._data),
      inventoryIsFull=repr(self._inventoryIsFull))

Anki.Cozmo.NeedsReward = NeedsReward
del NeedsReward


class NeedsStateOnRobot(object):
  "Generated message-passing structure."

  __slots__ = (
    '_version',                  # int_32
    '_timeLastWritten',          # uint_64
    '_curNeedLevel',             # int_32[10]
    '_curNeedsUnlockLevel',      # int_32
    '_numStarsAwarded',          # int_32
    '_partIsDamaged',            # bool[32]
    '_timeLastStarAwarded',      # uint_64
    '_onboardingStageCompleted', # int_32
    '_forceNextSong',            # Anki.Cozmo.UnlockId
    '_timeCreated',              # uint_64
  )

  @property
  def version(self):
    "int_32 version struct property."
    return self._version

  @version.setter
  def version(self, value):
    self._version = msgbuffers.validate_integer(
      'NeedsStateOnRobot.version', value, -2147483648, 2147483647)

  @property
  def timeLastWritten(self):
    "uint_64 timeLastWritten struct property."
    return self._timeLastWritten

  @timeLastWritten.setter
  def timeLastWritten(self, value):
    self._timeLastWritten = msgbuffers.validate_integer(
      'NeedsStateOnRobot.timeLastWritten', value, 0, 18446744073709551615)

  @property
  def curNeedLevel(self):
    "int_32[10] curNeedLevel struct property."
    return self._curNeedLevel

  @curNeedLevel.setter
  def curNeedLevel(self, value):
    self._curNeedLevel = msgbuffers.validate_farray(
      'NeedsStateOnRobot.curNeedLevel', value, 10,
      lambda name, value_inner: msgbuffers.validate_integer(
        name, value_inner, -2147483648, 2147483647))

  @property
  def curNeedsUnlockLevel(self):
    "int_32 curNeedsUnlockLevel struct property."
    return self._curNeedsUnlockLevel

  @curNeedsUnlockLevel.setter
  def curNeedsUnlockLevel(self, value):
    self._curNeedsUnlockLevel = msgbuffers.validate_integer(
      'NeedsStateOnRobot.curNeedsUnlockLevel', value, -2147483648, 2147483647)

  @property
  def numStarsAwarded(self):
    "int_32 numStarsAwarded struct property."
    return self._numStarsAwarded

  @numStarsAwarded.setter
  def numStarsAwarded(self, value):
    self._numStarsAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot.numStarsAwarded', value, -2147483648, 2147483647)

  @property
  def partIsDamaged(self):
    "bool[32] partIsDamaged struct property."
    return self._partIsDamaged

  @partIsDamaged.setter
  def partIsDamaged(self, value):
    self._partIsDamaged = msgbuffers.validate_farray(
      'NeedsStateOnRobot.partIsDamaged', value, 32,
      lambda name, value_inner: msgbuffers.validate_bool(
        name, value_inner))

  @property
  def timeLastStarAwarded(self):
    "uint_64 timeLastStarAwarded struct property."
    return self._timeLastStarAwarded

  @timeLastStarAwarded.setter
  def timeLastStarAwarded(self, value):
    self._timeLastStarAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot.timeLastStarAwarded', value, 0, 18446744073709551615)

  @property
  def onboardingStageCompleted(self):
    "int_32 onboardingStageCompleted struct property."
    return self._onboardingStageCompleted

  @onboardingStageCompleted.setter
  def onboardingStageCompleted(self, value):
    self._onboardingStageCompleted = msgbuffers.validate_integer(
      'NeedsStateOnRobot.onboardingStageCompleted', value, -2147483648, 2147483647)

  @property
  def forceNextSong(self):
    "Anki.Cozmo.UnlockId forceNextSong struct property."
    return self._forceNextSong

  @forceNextSong.setter
  def forceNextSong(self, value):
    self._forceNextSong = msgbuffers.validate_integer(
      'NeedsStateOnRobot.forceNextSong', value, -2147483648, 2147483647)

  @property
  def timeCreated(self):
    "uint_64 timeCreated struct property."
    return self._timeCreated

  @timeCreated.setter
  def timeCreated(self, value):
    self._timeCreated = msgbuffers.validate_integer(
      'NeedsStateOnRobot.timeCreated', value, 0, 18446744073709551615)

  def __init__(self, version=0, timeLastWritten=0, curNeedLevel=(0,) * 10, curNeedsUnlockLevel=0, numStarsAwarded=0, partIsDamaged=(False,) * 32, timeLastStarAwarded=0, onboardingStageCompleted=0, forceNextSong=Anki.Cozmo.UnlockId.Invalid, timeCreated=0):
    self.version = version
    self.timeLastWritten = timeLastWritten
    self.curNeedLevel = curNeedLevel
    self.curNeedsUnlockLevel = curNeedsUnlockLevel
    self.numStarsAwarded = numStarsAwarded
    self.partIsDamaged = partIsDamaged
    self.timeLastStarAwarded = timeLastStarAwarded
    self.onboardingStageCompleted = onboardingStageCompleted
    self.forceNextSong = forceNextSong
    self.timeCreated = timeCreated

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NeedsStateOnRobot from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NeedsStateOnRobot.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NeedsStateOnRobot from the given BinaryReader."
    _version = reader.read('i')
    _timeLastWritten = reader.read('Q')
    _curNeedLevel = reader.read_farray('i', 10)
    _curNeedsUnlockLevel = reader.read('i')
    _numStarsAwarded = reader.read('i')
    _partIsDamaged = list(map(bool, reader.read_farray('b', 32)))
    _timeLastStarAwarded = reader.read('Q')
    _onboardingStageCompleted = reader.read('i')
    _forceNextSong = reader.read('i')
    _timeCreated = reader.read('Q')
    return cls(_version, _timeLastWritten, _curNeedLevel, _curNeedsUnlockLevel, _numStarsAwarded, _partIsDamaged, _timeLastStarAwarded, _onboardingStageCompleted, _forceNextSong, _timeCreated)

  def pack(self):
    "Writes the current NeedsStateOnRobot, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NeedsStateOnRobot to the given BinaryWriter."
    writer.write(self._version, 'i')
    writer.write(self._timeLastWritten, 'Q')
    writer.write_farray(self._curNeedLevel, 'i', 10)
    writer.write(self._curNeedsUnlockLevel, 'i')
    writer.write(self._numStarsAwarded, 'i')
    writer.write_farray(list(map(int, self._partIsDamaged)), 'b', 32)
    writer.write(self._timeLastStarAwarded, 'Q')
    writer.write(self._onboardingStageCompleted, 'i')
    writer.write(self._forceNextSong, 'i')
    writer.write(self._timeCreated, 'Q')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._version == other._version and
        self._timeLastWritten == other._timeLastWritten and
        self._curNeedLevel == other._curNeedLevel and
        self._curNeedsUnlockLevel == other._curNeedsUnlockLevel and
        self._numStarsAwarded == other._numStarsAwarded and
        self._partIsDamaged == other._partIsDamaged and
        self._timeLastStarAwarded == other._timeLastStarAwarded and
        self._onboardingStageCompleted == other._onboardingStageCompleted and
        self._forceNextSong == other._forceNextSong and
        self._timeCreated == other._timeCreated)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._version, 'i') +
      msgbuffers.size(self._timeLastWritten, 'Q') +
      msgbuffers.size_farray(self._curNeedLevel, 'i', 10) +
      msgbuffers.size(self._curNeedsUnlockLevel, 'i') +
      msgbuffers.size(self._numStarsAwarded, 'i') +
      msgbuffers.size_farray(self._partIsDamaged, 'b', 32) +
      msgbuffers.size(self._timeLastStarAwarded, 'Q') +
      msgbuffers.size(self._onboardingStageCompleted, 'i') +
      msgbuffers.size(self._forceNextSong, 'i') +
      msgbuffers.size(self._timeCreated, 'Q'))

  def __str__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged}, timeLastStarAwarded={timeLastStarAwarded}, onboardingStageCompleted={onboardingStageCompleted}, forceNextSong={forceNextSong}, timeCreated={timeCreated})'.format(
      type=type(self).__name__,
      version=self._version,
      timeLastWritten=self._timeLastWritten,
      curNeedLevel=msgbuffers.shorten_sequence(self._curNeedLevel),
      curNeedsUnlockLevel=self._curNeedsUnlockLevel,
      numStarsAwarded=self._numStarsAwarded,
      partIsDamaged=msgbuffers.shorten_sequence(self._partIsDamaged),
      timeLastStarAwarded=self._timeLastStarAwarded,
      onboardingStageCompleted=self._onboardingStageCompleted,
      forceNextSong=self._forceNextSong,
      timeCreated=self._timeCreated)

  def __repr__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged}, timeLastStarAwarded={timeLastStarAwarded}, onboardingStageCompleted={onboardingStageCompleted}, forceNextSong={forceNextSong}, timeCreated={timeCreated})'.format(
      type=type(self).__name__,
      version=repr(self._version),
      timeLastWritten=repr(self._timeLastWritten),
      curNeedLevel=repr(self._curNeedLevel),
      curNeedsUnlockLevel=repr(self._curNeedsUnlockLevel),
      numStarsAwarded=repr(self._numStarsAwarded),
      partIsDamaged=repr(self._partIsDamaged),
      timeLastStarAwarded=repr(self._timeLastStarAwarded),
      onboardingStageCompleted=repr(self._onboardingStageCompleted),
      forceNextSong=repr(self._forceNextSong),
      timeCreated=repr(self._timeCreated))

Anki.Cozmo.NeedsStateOnRobot = NeedsStateOnRobot
del NeedsStateOnRobot


class NeedsStateOnRobot_v04(object):
  "Generated message-passing structure."

  __slots__ = (
    '_version',                  # int_32
    '_timeLastWritten',          # uint_64
    '_curNeedLevel',             # int_32[10]
    '_curNeedsUnlockLevel',      # int_32
    '_numStarsAwarded',          # int_32
    '_partIsDamaged',            # bool[32]
    '_timeLastStarAwarded',      # uint_64
    '_onboardingStageCompleted', # int_32
    '_forceNextSong',            # Anki.Cozmo.UnlockId
  )

  @property
  def version(self):
    "int_32 version struct property."
    return self._version

  @version.setter
  def version(self, value):
    self._version = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v04.version', value, -2147483648, 2147483647)

  @property
  def timeLastWritten(self):
    "uint_64 timeLastWritten struct property."
    return self._timeLastWritten

  @timeLastWritten.setter
  def timeLastWritten(self, value):
    self._timeLastWritten = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v04.timeLastWritten', value, 0, 18446744073709551615)

  @property
  def curNeedLevel(self):
    "int_32[10] curNeedLevel struct property."
    return self._curNeedLevel

  @curNeedLevel.setter
  def curNeedLevel(self, value):
    self._curNeedLevel = msgbuffers.validate_farray(
      'NeedsStateOnRobot_v04.curNeedLevel', value, 10,
      lambda name, value_inner: msgbuffers.validate_integer(
        name, value_inner, -2147483648, 2147483647))

  @property
  def curNeedsUnlockLevel(self):
    "int_32 curNeedsUnlockLevel struct property."
    return self._curNeedsUnlockLevel

  @curNeedsUnlockLevel.setter
  def curNeedsUnlockLevel(self, value):
    self._curNeedsUnlockLevel = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v04.curNeedsUnlockLevel', value, -2147483648, 2147483647)

  @property
  def numStarsAwarded(self):
    "int_32 numStarsAwarded struct property."
    return self._numStarsAwarded

  @numStarsAwarded.setter
  def numStarsAwarded(self, value):
    self._numStarsAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v04.numStarsAwarded', value, -2147483648, 2147483647)

  @property
  def partIsDamaged(self):
    "bool[32] partIsDamaged struct property."
    return self._partIsDamaged

  @partIsDamaged.setter
  def partIsDamaged(self, value):
    self._partIsDamaged = msgbuffers.validate_farray(
      'NeedsStateOnRobot_v04.partIsDamaged', value, 32,
      lambda name, value_inner: msgbuffers.validate_bool(
        name, value_inner))

  @property
  def timeLastStarAwarded(self):
    "uint_64 timeLastStarAwarded struct property."
    return self._timeLastStarAwarded

  @timeLastStarAwarded.setter
  def timeLastStarAwarded(self, value):
    self._timeLastStarAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v04.timeLastStarAwarded', value, 0, 18446744073709551615)

  @property
  def onboardingStageCompleted(self):
    "int_32 onboardingStageCompleted struct property."
    return self._onboardingStageCompleted

  @onboardingStageCompleted.setter
  def onboardingStageCompleted(self, value):
    self._onboardingStageCompleted = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v04.onboardingStageCompleted', value, -2147483648, 2147483647)

  @property
  def forceNextSong(self):
    "Anki.Cozmo.UnlockId forceNextSong struct property."
    return self._forceNextSong

  @forceNextSong.setter
  def forceNextSong(self, value):
    self._forceNextSong = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v04.forceNextSong', value, -2147483648, 2147483647)

  def __init__(self, version=0, timeLastWritten=0, curNeedLevel=(0,) * 10, curNeedsUnlockLevel=0, numStarsAwarded=0, partIsDamaged=(False,) * 32, timeLastStarAwarded=0, onboardingStageCompleted=0, forceNextSong=Anki.Cozmo.UnlockId.Invalid):
    self.version = version
    self.timeLastWritten = timeLastWritten
    self.curNeedLevel = curNeedLevel
    self.curNeedsUnlockLevel = curNeedsUnlockLevel
    self.numStarsAwarded = numStarsAwarded
    self.partIsDamaged = partIsDamaged
    self.timeLastStarAwarded = timeLastStarAwarded
    self.onboardingStageCompleted = onboardingStageCompleted
    self.forceNextSong = forceNextSong

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NeedsStateOnRobot_v04 from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NeedsStateOnRobot_v04.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NeedsStateOnRobot_v04 from the given BinaryReader."
    _version = reader.read('i')
    _timeLastWritten = reader.read('Q')
    _curNeedLevel = reader.read_farray('i', 10)
    _curNeedsUnlockLevel = reader.read('i')
    _numStarsAwarded = reader.read('i')
    _partIsDamaged = list(map(bool, reader.read_farray('b', 32)))
    _timeLastStarAwarded = reader.read('Q')
    _onboardingStageCompleted = reader.read('i')
    _forceNextSong = reader.read('i')
    return cls(_version, _timeLastWritten, _curNeedLevel, _curNeedsUnlockLevel, _numStarsAwarded, _partIsDamaged, _timeLastStarAwarded, _onboardingStageCompleted, _forceNextSong)

  def pack(self):
    "Writes the current NeedsStateOnRobot_v04, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NeedsStateOnRobot_v04 to the given BinaryWriter."
    writer.write(self._version, 'i')
    writer.write(self._timeLastWritten, 'Q')
    writer.write_farray(self._curNeedLevel, 'i', 10)
    writer.write(self._curNeedsUnlockLevel, 'i')
    writer.write(self._numStarsAwarded, 'i')
    writer.write_farray(list(map(int, self._partIsDamaged)), 'b', 32)
    writer.write(self._timeLastStarAwarded, 'Q')
    writer.write(self._onboardingStageCompleted, 'i')
    writer.write(self._forceNextSong, 'i')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._version == other._version and
        self._timeLastWritten == other._timeLastWritten and
        self._curNeedLevel == other._curNeedLevel and
        self._curNeedsUnlockLevel == other._curNeedsUnlockLevel and
        self._numStarsAwarded == other._numStarsAwarded and
        self._partIsDamaged == other._partIsDamaged and
        self._timeLastStarAwarded == other._timeLastStarAwarded and
        self._onboardingStageCompleted == other._onboardingStageCompleted and
        self._forceNextSong == other._forceNextSong)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._version, 'i') +
      msgbuffers.size(self._timeLastWritten, 'Q') +
      msgbuffers.size_farray(self._curNeedLevel, 'i', 10) +
      msgbuffers.size(self._curNeedsUnlockLevel, 'i') +
      msgbuffers.size(self._numStarsAwarded, 'i') +
      msgbuffers.size_farray(self._partIsDamaged, 'b', 32) +
      msgbuffers.size(self._timeLastStarAwarded, 'Q') +
      msgbuffers.size(self._onboardingStageCompleted, 'i') +
      msgbuffers.size(self._forceNextSong, 'i'))

  def __str__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged}, timeLastStarAwarded={timeLastStarAwarded}, onboardingStageCompleted={onboardingStageCompleted}, forceNextSong={forceNextSong})'.format(
      type=type(self).__name__,
      version=self._version,
      timeLastWritten=self._timeLastWritten,
      curNeedLevel=msgbuffers.shorten_sequence(self._curNeedLevel),
      curNeedsUnlockLevel=self._curNeedsUnlockLevel,
      numStarsAwarded=self._numStarsAwarded,
      partIsDamaged=msgbuffers.shorten_sequence(self._partIsDamaged),
      timeLastStarAwarded=self._timeLastStarAwarded,
      onboardingStageCompleted=self._onboardingStageCompleted,
      forceNextSong=self._forceNextSong)

  def __repr__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged}, timeLastStarAwarded={timeLastStarAwarded}, onboardingStageCompleted={onboardingStageCompleted}, forceNextSong={forceNextSong})'.format(
      type=type(self).__name__,
      version=repr(self._version),
      timeLastWritten=repr(self._timeLastWritten),
      curNeedLevel=repr(self._curNeedLevel),
      curNeedsUnlockLevel=repr(self._curNeedsUnlockLevel),
      numStarsAwarded=repr(self._numStarsAwarded),
      partIsDamaged=repr(self._partIsDamaged),
      timeLastStarAwarded=repr(self._timeLastStarAwarded),
      onboardingStageCompleted=repr(self._onboardingStageCompleted),
      forceNextSong=repr(self._forceNextSong))

Anki.Cozmo.NeedsStateOnRobot_v04 = NeedsStateOnRobot_v04
del NeedsStateOnRobot_v04


class NeedsStateOnRobot_v03(object):
  "Generated message-passing structure."

  __slots__ = (
    '_version',                  # int_32
    '_timeLastWritten',          # uint_64
    '_curNeedLevel',             # int_32[10]
    '_curNeedsUnlockLevel',      # int_32
    '_numStarsAwarded',          # int_32
    '_partIsDamaged',            # bool[32]
    '_timeLastStarAwarded',      # uint_64
    '_onboardingStageCompleted', # int_32
  )

  @property
  def version(self):
    "int_32 version struct property."
    return self._version

  @version.setter
  def version(self, value):
    self._version = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v03.version', value, -2147483648, 2147483647)

  @property
  def timeLastWritten(self):
    "uint_64 timeLastWritten struct property."
    return self._timeLastWritten

  @timeLastWritten.setter
  def timeLastWritten(self, value):
    self._timeLastWritten = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v03.timeLastWritten', value, 0, 18446744073709551615)

  @property
  def curNeedLevel(self):
    "int_32[10] curNeedLevel struct property."
    return self._curNeedLevel

  @curNeedLevel.setter
  def curNeedLevel(self, value):
    self._curNeedLevel = msgbuffers.validate_farray(
      'NeedsStateOnRobot_v03.curNeedLevel', value, 10,
      lambda name, value_inner: msgbuffers.validate_integer(
        name, value_inner, -2147483648, 2147483647))

  @property
  def curNeedsUnlockLevel(self):
    "int_32 curNeedsUnlockLevel struct property."
    return self._curNeedsUnlockLevel

  @curNeedsUnlockLevel.setter
  def curNeedsUnlockLevel(self, value):
    self._curNeedsUnlockLevel = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v03.curNeedsUnlockLevel', value, -2147483648, 2147483647)

  @property
  def numStarsAwarded(self):
    "int_32 numStarsAwarded struct property."
    return self._numStarsAwarded

  @numStarsAwarded.setter
  def numStarsAwarded(self, value):
    self._numStarsAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v03.numStarsAwarded', value, -2147483648, 2147483647)

  @property
  def partIsDamaged(self):
    "bool[32] partIsDamaged struct property."
    return self._partIsDamaged

  @partIsDamaged.setter
  def partIsDamaged(self, value):
    self._partIsDamaged = msgbuffers.validate_farray(
      'NeedsStateOnRobot_v03.partIsDamaged', value, 32,
      lambda name, value_inner: msgbuffers.validate_bool(
        name, value_inner))

  @property
  def timeLastStarAwarded(self):
    "uint_64 timeLastStarAwarded struct property."
    return self._timeLastStarAwarded

  @timeLastStarAwarded.setter
  def timeLastStarAwarded(self, value):
    self._timeLastStarAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v03.timeLastStarAwarded', value, 0, 18446744073709551615)

  @property
  def onboardingStageCompleted(self):
    "int_32 onboardingStageCompleted struct property."
    return self._onboardingStageCompleted

  @onboardingStageCompleted.setter
  def onboardingStageCompleted(self, value):
    self._onboardingStageCompleted = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v03.onboardingStageCompleted', value, -2147483648, 2147483647)

  def __init__(self, version=0, timeLastWritten=0, curNeedLevel=(0,) * 10, curNeedsUnlockLevel=0, numStarsAwarded=0, partIsDamaged=(False,) * 32, timeLastStarAwarded=0, onboardingStageCompleted=0):
    self.version = version
    self.timeLastWritten = timeLastWritten
    self.curNeedLevel = curNeedLevel
    self.curNeedsUnlockLevel = curNeedsUnlockLevel
    self.numStarsAwarded = numStarsAwarded
    self.partIsDamaged = partIsDamaged
    self.timeLastStarAwarded = timeLastStarAwarded
    self.onboardingStageCompleted = onboardingStageCompleted

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NeedsStateOnRobot_v03 from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NeedsStateOnRobot_v03.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NeedsStateOnRobot_v03 from the given BinaryReader."
    _version = reader.read('i')
    _timeLastWritten = reader.read('Q')
    _curNeedLevel = reader.read_farray('i', 10)
    _curNeedsUnlockLevel = reader.read('i')
    _numStarsAwarded = reader.read('i')
    _partIsDamaged = list(map(bool, reader.read_farray('b', 32)))
    _timeLastStarAwarded = reader.read('Q')
    _onboardingStageCompleted = reader.read('i')
    return cls(_version, _timeLastWritten, _curNeedLevel, _curNeedsUnlockLevel, _numStarsAwarded, _partIsDamaged, _timeLastStarAwarded, _onboardingStageCompleted)

  def pack(self):
    "Writes the current NeedsStateOnRobot_v03, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NeedsStateOnRobot_v03 to the given BinaryWriter."
    writer.write(self._version, 'i')
    writer.write(self._timeLastWritten, 'Q')
    writer.write_farray(self._curNeedLevel, 'i', 10)
    writer.write(self._curNeedsUnlockLevel, 'i')
    writer.write(self._numStarsAwarded, 'i')
    writer.write_farray(list(map(int, self._partIsDamaged)), 'b', 32)
    writer.write(self._timeLastStarAwarded, 'Q')
    writer.write(self._onboardingStageCompleted, 'i')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._version == other._version and
        self._timeLastWritten == other._timeLastWritten and
        self._curNeedLevel == other._curNeedLevel and
        self._curNeedsUnlockLevel == other._curNeedsUnlockLevel and
        self._numStarsAwarded == other._numStarsAwarded and
        self._partIsDamaged == other._partIsDamaged and
        self._timeLastStarAwarded == other._timeLastStarAwarded and
        self._onboardingStageCompleted == other._onboardingStageCompleted)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._version, 'i') +
      msgbuffers.size(self._timeLastWritten, 'Q') +
      msgbuffers.size_farray(self._curNeedLevel, 'i', 10) +
      msgbuffers.size(self._curNeedsUnlockLevel, 'i') +
      msgbuffers.size(self._numStarsAwarded, 'i') +
      msgbuffers.size_farray(self._partIsDamaged, 'b', 32) +
      msgbuffers.size(self._timeLastStarAwarded, 'Q') +
      msgbuffers.size(self._onboardingStageCompleted, 'i'))

  def __str__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged}, timeLastStarAwarded={timeLastStarAwarded}, onboardingStageCompleted={onboardingStageCompleted})'.format(
      type=type(self).__name__,
      version=self._version,
      timeLastWritten=self._timeLastWritten,
      curNeedLevel=msgbuffers.shorten_sequence(self._curNeedLevel),
      curNeedsUnlockLevel=self._curNeedsUnlockLevel,
      numStarsAwarded=self._numStarsAwarded,
      partIsDamaged=msgbuffers.shorten_sequence(self._partIsDamaged),
      timeLastStarAwarded=self._timeLastStarAwarded,
      onboardingStageCompleted=self._onboardingStageCompleted)

  def __repr__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged}, timeLastStarAwarded={timeLastStarAwarded}, onboardingStageCompleted={onboardingStageCompleted})'.format(
      type=type(self).__name__,
      version=repr(self._version),
      timeLastWritten=repr(self._timeLastWritten),
      curNeedLevel=repr(self._curNeedLevel),
      curNeedsUnlockLevel=repr(self._curNeedsUnlockLevel),
      numStarsAwarded=repr(self._numStarsAwarded),
      partIsDamaged=repr(self._partIsDamaged),
      timeLastStarAwarded=repr(self._timeLastStarAwarded),
      onboardingStageCompleted=repr(self._onboardingStageCompleted))

Anki.Cozmo.NeedsStateOnRobot_v03 = NeedsStateOnRobot_v03
del NeedsStateOnRobot_v03


class NeedsStateOnRobot_v02(object):
  "Generated message-passing structure."

  __slots__ = (
    '_version',             # int_32
    '_timeLastWritten',     # uint_64
    '_curNeedLevel',        # int_32[10]
    '_curNeedsUnlockLevel', # int_32
    '_numStarsAwarded',     # int_32
    '_partIsDamaged',       # bool[32]
    '_timeLastStarAwarded', # uint_64
  )

  @property
  def version(self):
    "int_32 version struct property."
    return self._version

  @version.setter
  def version(self, value):
    self._version = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v02.version', value, -2147483648, 2147483647)

  @property
  def timeLastWritten(self):
    "uint_64 timeLastWritten struct property."
    return self._timeLastWritten

  @timeLastWritten.setter
  def timeLastWritten(self, value):
    self._timeLastWritten = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v02.timeLastWritten', value, 0, 18446744073709551615)

  @property
  def curNeedLevel(self):
    "int_32[10] curNeedLevel struct property."
    return self._curNeedLevel

  @curNeedLevel.setter
  def curNeedLevel(self, value):
    self._curNeedLevel = msgbuffers.validate_farray(
      'NeedsStateOnRobot_v02.curNeedLevel', value, 10,
      lambda name, value_inner: msgbuffers.validate_integer(
        name, value_inner, -2147483648, 2147483647))

  @property
  def curNeedsUnlockLevel(self):
    "int_32 curNeedsUnlockLevel struct property."
    return self._curNeedsUnlockLevel

  @curNeedsUnlockLevel.setter
  def curNeedsUnlockLevel(self, value):
    self._curNeedsUnlockLevel = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v02.curNeedsUnlockLevel', value, -2147483648, 2147483647)

  @property
  def numStarsAwarded(self):
    "int_32 numStarsAwarded struct property."
    return self._numStarsAwarded

  @numStarsAwarded.setter
  def numStarsAwarded(self, value):
    self._numStarsAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v02.numStarsAwarded', value, -2147483648, 2147483647)

  @property
  def partIsDamaged(self):
    "bool[32] partIsDamaged struct property."
    return self._partIsDamaged

  @partIsDamaged.setter
  def partIsDamaged(self, value):
    self._partIsDamaged = msgbuffers.validate_farray(
      'NeedsStateOnRobot_v02.partIsDamaged', value, 32,
      lambda name, value_inner: msgbuffers.validate_bool(
        name, value_inner))

  @property
  def timeLastStarAwarded(self):
    "uint_64 timeLastStarAwarded struct property."
    return self._timeLastStarAwarded

  @timeLastStarAwarded.setter
  def timeLastStarAwarded(self, value):
    self._timeLastStarAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v02.timeLastStarAwarded', value, 0, 18446744073709551615)

  def __init__(self, version=0, timeLastWritten=0, curNeedLevel=(0,) * 10, curNeedsUnlockLevel=0, numStarsAwarded=0, partIsDamaged=(False,) * 32, timeLastStarAwarded=0):
    self.version = version
    self.timeLastWritten = timeLastWritten
    self.curNeedLevel = curNeedLevel
    self.curNeedsUnlockLevel = curNeedsUnlockLevel
    self.numStarsAwarded = numStarsAwarded
    self.partIsDamaged = partIsDamaged
    self.timeLastStarAwarded = timeLastStarAwarded

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NeedsStateOnRobot_v02 from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NeedsStateOnRobot_v02.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NeedsStateOnRobot_v02 from the given BinaryReader."
    _version = reader.read('i')
    _timeLastWritten = reader.read('Q')
    _curNeedLevel = reader.read_farray('i', 10)
    _curNeedsUnlockLevel = reader.read('i')
    _numStarsAwarded = reader.read('i')
    _partIsDamaged = list(map(bool, reader.read_farray('b', 32)))
    _timeLastStarAwarded = reader.read('Q')
    return cls(_version, _timeLastWritten, _curNeedLevel, _curNeedsUnlockLevel, _numStarsAwarded, _partIsDamaged, _timeLastStarAwarded)

  def pack(self):
    "Writes the current NeedsStateOnRobot_v02, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NeedsStateOnRobot_v02 to the given BinaryWriter."
    writer.write(self._version, 'i')
    writer.write(self._timeLastWritten, 'Q')
    writer.write_farray(self._curNeedLevel, 'i', 10)
    writer.write(self._curNeedsUnlockLevel, 'i')
    writer.write(self._numStarsAwarded, 'i')
    writer.write_farray(list(map(int, self._partIsDamaged)), 'b', 32)
    writer.write(self._timeLastStarAwarded, 'Q')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._version == other._version and
        self._timeLastWritten == other._timeLastWritten and
        self._curNeedLevel == other._curNeedLevel and
        self._curNeedsUnlockLevel == other._curNeedsUnlockLevel and
        self._numStarsAwarded == other._numStarsAwarded and
        self._partIsDamaged == other._partIsDamaged and
        self._timeLastStarAwarded == other._timeLastStarAwarded)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._version, 'i') +
      msgbuffers.size(self._timeLastWritten, 'Q') +
      msgbuffers.size_farray(self._curNeedLevel, 'i', 10) +
      msgbuffers.size(self._curNeedsUnlockLevel, 'i') +
      msgbuffers.size(self._numStarsAwarded, 'i') +
      msgbuffers.size_farray(self._partIsDamaged, 'b', 32) +
      msgbuffers.size(self._timeLastStarAwarded, 'Q'))

  def __str__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged}, timeLastStarAwarded={timeLastStarAwarded})'.format(
      type=type(self).__name__,
      version=self._version,
      timeLastWritten=self._timeLastWritten,
      curNeedLevel=msgbuffers.shorten_sequence(self._curNeedLevel),
      curNeedsUnlockLevel=self._curNeedsUnlockLevel,
      numStarsAwarded=self._numStarsAwarded,
      partIsDamaged=msgbuffers.shorten_sequence(self._partIsDamaged),
      timeLastStarAwarded=self._timeLastStarAwarded)

  def __repr__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged}, timeLastStarAwarded={timeLastStarAwarded})'.format(
      type=type(self).__name__,
      version=repr(self._version),
      timeLastWritten=repr(self._timeLastWritten),
      curNeedLevel=repr(self._curNeedLevel),
      curNeedsUnlockLevel=repr(self._curNeedsUnlockLevel),
      numStarsAwarded=repr(self._numStarsAwarded),
      partIsDamaged=repr(self._partIsDamaged),
      timeLastStarAwarded=repr(self._timeLastStarAwarded))

Anki.Cozmo.NeedsStateOnRobot_v02 = NeedsStateOnRobot_v02
del NeedsStateOnRobot_v02


class NeedsStateOnRobot_v01(object):
  "Generated message-passing structure."

  __slots__ = (
    '_version',             # int_32
    '_timeLastWritten',     # uint_64
    '_curNeedLevel',        # int_32[10]
    '_curNeedsUnlockLevel', # int_32
    '_numStarsAwarded',     # int_32
    '_partIsDamaged',       # bool[32]
  )

  @property
  def version(self):
    "int_32 version struct property."
    return self._version

  @version.setter
  def version(self, value):
    self._version = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v01.version', value, -2147483648, 2147483647)

  @property
  def timeLastWritten(self):
    "uint_64 timeLastWritten struct property."
    return self._timeLastWritten

  @timeLastWritten.setter
  def timeLastWritten(self, value):
    self._timeLastWritten = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v01.timeLastWritten', value, 0, 18446744073709551615)

  @property
  def curNeedLevel(self):
    "int_32[10] curNeedLevel struct property."
    return self._curNeedLevel

  @curNeedLevel.setter
  def curNeedLevel(self, value):
    self._curNeedLevel = msgbuffers.validate_farray(
      'NeedsStateOnRobot_v01.curNeedLevel', value, 10,
      lambda name, value_inner: msgbuffers.validate_integer(
        name, value_inner, -2147483648, 2147483647))

  @property
  def curNeedsUnlockLevel(self):
    "int_32 curNeedsUnlockLevel struct property."
    return self._curNeedsUnlockLevel

  @curNeedsUnlockLevel.setter
  def curNeedsUnlockLevel(self, value):
    self._curNeedsUnlockLevel = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v01.curNeedsUnlockLevel', value, -2147483648, 2147483647)

  @property
  def numStarsAwarded(self):
    "int_32 numStarsAwarded struct property."
    return self._numStarsAwarded

  @numStarsAwarded.setter
  def numStarsAwarded(self, value):
    self._numStarsAwarded = msgbuffers.validate_integer(
      'NeedsStateOnRobot_v01.numStarsAwarded', value, -2147483648, 2147483647)

  @property
  def partIsDamaged(self):
    "bool[32] partIsDamaged struct property."
    return self._partIsDamaged

  @partIsDamaged.setter
  def partIsDamaged(self, value):
    self._partIsDamaged = msgbuffers.validate_farray(
      'NeedsStateOnRobot_v01.partIsDamaged', value, 32,
      lambda name, value_inner: msgbuffers.validate_bool(
        name, value_inner))

  def __init__(self, version=0, timeLastWritten=0, curNeedLevel=(0,) * 10, curNeedsUnlockLevel=0, numStarsAwarded=0, partIsDamaged=(False,) * 32):
    self.version = version
    self.timeLastWritten = timeLastWritten
    self.curNeedLevel = curNeedLevel
    self.curNeedsUnlockLevel = curNeedsUnlockLevel
    self.numStarsAwarded = numStarsAwarded
    self.partIsDamaged = partIsDamaged

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NeedsStateOnRobot_v01 from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NeedsStateOnRobot_v01.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NeedsStateOnRobot_v01 from the given BinaryReader."
    _version = reader.read('i')
    _timeLastWritten = reader.read('Q')
    _curNeedLevel = reader.read_farray('i', 10)
    _curNeedsUnlockLevel = reader.read('i')
    _numStarsAwarded = reader.read('i')
    _partIsDamaged = list(map(bool, reader.read_farray('b', 32)))
    return cls(_version, _timeLastWritten, _curNeedLevel, _curNeedsUnlockLevel, _numStarsAwarded, _partIsDamaged)

  def pack(self):
    "Writes the current NeedsStateOnRobot_v01, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NeedsStateOnRobot_v01 to the given BinaryWriter."
    writer.write(self._version, 'i')
    writer.write(self._timeLastWritten, 'Q')
    writer.write_farray(self._curNeedLevel, 'i', 10)
    writer.write(self._curNeedsUnlockLevel, 'i')
    writer.write(self._numStarsAwarded, 'i')
    writer.write_farray(list(map(int, self._partIsDamaged)), 'b', 32)

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._version == other._version and
        self._timeLastWritten == other._timeLastWritten and
        self._curNeedLevel == other._curNeedLevel and
        self._curNeedsUnlockLevel == other._curNeedsUnlockLevel and
        self._numStarsAwarded == other._numStarsAwarded and
        self._partIsDamaged == other._partIsDamaged)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._version, 'i') +
      msgbuffers.size(self._timeLastWritten, 'Q') +
      msgbuffers.size_farray(self._curNeedLevel, 'i', 10) +
      msgbuffers.size(self._curNeedsUnlockLevel, 'i') +
      msgbuffers.size(self._numStarsAwarded, 'i') +
      msgbuffers.size_farray(self._partIsDamaged, 'b', 32))

  def __str__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged})'.format(
      type=type(self).__name__,
      version=self._version,
      timeLastWritten=self._timeLastWritten,
      curNeedLevel=msgbuffers.shorten_sequence(self._curNeedLevel),
      curNeedsUnlockLevel=self._curNeedsUnlockLevel,
      numStarsAwarded=self._numStarsAwarded,
      partIsDamaged=msgbuffers.shorten_sequence(self._partIsDamaged))

  def __repr__(self):
    return '{type}(version={version}, timeLastWritten={timeLastWritten}, curNeedLevel={curNeedLevel}, curNeedsUnlockLevel={curNeedsUnlockLevel}, numStarsAwarded={numStarsAwarded}, partIsDamaged={partIsDamaged})'.format(
      type=type(self).__name__,
      version=repr(self._version),
      timeLastWritten=repr(self._timeLastWritten),
      curNeedLevel=repr(self._curNeedLevel),
      curNeedsUnlockLevel=repr(self._curNeedsUnlockLevel),
      numStarsAwarded=repr(self._numStarsAwarded),
      partIsDamaged=repr(self._partIsDamaged))

Anki.Cozmo.NeedsStateOnRobot_v01 = NeedsStateOnRobot_v01
del NeedsStateOnRobot_v01


class UnlockLevel(object):
  "Generated message-passing structure."

  __slots__ = (
    '_rewards',                    # NeedsReward[uint_8]
    '_numStarsToUnlock',           # int_32
    '_targetSparksTotal',          # int_32
    '_maxPriorLevelUnlocks',       # int_32
    '_minSparksPct',               # float_32
    '_maxSparksPct',               # float_32
    '_minSparks',                  # int_32
    '_minMaxSparks',               # int_32
    '_freeplayTargetSparksTotal',  # int_32
    '_freeplayMinSparksRewardPct', # float_32
    '_freeplayMinSparksPct',       # float_32
    '_freeplayMaxSparksPct',       # float_32
    '_freeplayMinSparks',          # int_32
    '_freeplayMinMaxSparks',       # int_32
  )

  @property
  def rewards(self):
    "NeedsReward[uint_8] rewards struct property."
    return self._rewards

  @rewards.setter
  def rewards(self, value):
    self._rewards = msgbuffers.validate_varray(
      'UnlockLevel.rewards', value, 255,
      lambda name, value_inner: msgbuffers.validate_object(
        name, value_inner, Anki.Cozmo.NeedsReward))

  @property
  def numStarsToUnlock(self):
    "int_32 numStarsToUnlock struct property."
    return self._numStarsToUnlock

  @numStarsToUnlock.setter
  def numStarsToUnlock(self, value):
    self._numStarsToUnlock = msgbuffers.validate_integer(
      'UnlockLevel.numStarsToUnlock', value, -2147483648, 2147483647)

  @property
  def targetSparksTotal(self):
    "int_32 targetSparksTotal struct property."
    return self._targetSparksTotal

  @targetSparksTotal.setter
  def targetSparksTotal(self, value):
    self._targetSparksTotal = msgbuffers.validate_integer(
      'UnlockLevel.targetSparksTotal', value, -2147483648, 2147483647)

  @property
  def maxPriorLevelUnlocks(self):
    "int_32 maxPriorLevelUnlocks struct property."
    return self._maxPriorLevelUnlocks

  @maxPriorLevelUnlocks.setter
  def maxPriorLevelUnlocks(self, value):
    self._maxPriorLevelUnlocks = msgbuffers.validate_integer(
      'UnlockLevel.maxPriorLevelUnlocks', value, -2147483648, 2147483647)

  @property
  def minSparksPct(self):
    "float_32 minSparksPct struct property."
    return self._minSparksPct

  @minSparksPct.setter
  def minSparksPct(self, value):
    self._minSparksPct = msgbuffers.validate_float(
      'UnlockLevel.minSparksPct', value, 'f')

  @property
  def maxSparksPct(self):
    "float_32 maxSparksPct struct property."
    return self._maxSparksPct

  @maxSparksPct.setter
  def maxSparksPct(self, value):
    self._maxSparksPct = msgbuffers.validate_float(
      'UnlockLevel.maxSparksPct', value, 'f')

  @property
  def minSparks(self):
    "int_32 minSparks struct property."
    return self._minSparks

  @minSparks.setter
  def minSparks(self, value):
    self._minSparks = msgbuffers.validate_integer(
      'UnlockLevel.minSparks', value, -2147483648, 2147483647)

  @property
  def minMaxSparks(self):
    "int_32 minMaxSparks struct property."
    return self._minMaxSparks

  @minMaxSparks.setter
  def minMaxSparks(self, value):
    self._minMaxSparks = msgbuffers.validate_integer(
      'UnlockLevel.minMaxSparks', value, -2147483648, 2147483647)

  @property
  def freeplayTargetSparksTotal(self):
    "int_32 freeplayTargetSparksTotal struct property."
    return self._freeplayTargetSparksTotal

  @freeplayTargetSparksTotal.setter
  def freeplayTargetSparksTotal(self, value):
    self._freeplayTargetSparksTotal = msgbuffers.validate_integer(
      'UnlockLevel.freeplayTargetSparksTotal', value, -2147483648, 2147483647)

  @property
  def freeplayMinSparksRewardPct(self):
    "float_32 freeplayMinSparksRewardPct struct property."
    return self._freeplayMinSparksRewardPct

  @freeplayMinSparksRewardPct.setter
  def freeplayMinSparksRewardPct(self, value):
    self._freeplayMinSparksRewardPct = msgbuffers.validate_float(
      'UnlockLevel.freeplayMinSparksRewardPct', value, 'f')

  @property
  def freeplayMinSparksPct(self):
    "float_32 freeplayMinSparksPct struct property."
    return self._freeplayMinSparksPct

  @freeplayMinSparksPct.setter
  def freeplayMinSparksPct(self, value):
    self._freeplayMinSparksPct = msgbuffers.validate_float(
      'UnlockLevel.freeplayMinSparksPct', value, 'f')

  @property
  def freeplayMaxSparksPct(self):
    "float_32 freeplayMaxSparksPct struct property."
    return self._freeplayMaxSparksPct

  @freeplayMaxSparksPct.setter
  def freeplayMaxSparksPct(self, value):
    self._freeplayMaxSparksPct = msgbuffers.validate_float(
      'UnlockLevel.freeplayMaxSparksPct', value, 'f')

  @property
  def freeplayMinSparks(self):
    "int_32 freeplayMinSparks struct property."
    return self._freeplayMinSparks

  @freeplayMinSparks.setter
  def freeplayMinSparks(self, value):
    self._freeplayMinSparks = msgbuffers.validate_integer(
      'UnlockLevel.freeplayMinSparks', value, -2147483648, 2147483647)

  @property
  def freeplayMinMaxSparks(self):
    "int_32 freeplayMinMaxSparks struct property."
    return self._freeplayMinMaxSparks

  @freeplayMinMaxSparks.setter
  def freeplayMinMaxSparks(self, value):
    self._freeplayMinMaxSparks = msgbuffers.validate_integer(
      'UnlockLevel.freeplayMinMaxSparks', value, -2147483648, 2147483647)

  def __init__(self, rewards=(), numStarsToUnlock=0, targetSparksTotal=0, maxPriorLevelUnlocks=0, minSparksPct=0.0, maxSparksPct=0.0, minSparks=0, minMaxSparks=0, freeplayTargetSparksTotal=0, freeplayMinSparksRewardPct=0.0, freeplayMinSparksPct=0.0, freeplayMaxSparksPct=0.0, freeplayMinSparks=0, freeplayMinMaxSparks=0):
    self.rewards = rewards
    self.numStarsToUnlock = numStarsToUnlock
    self.targetSparksTotal = targetSparksTotal
    self.maxPriorLevelUnlocks = maxPriorLevelUnlocks
    self.minSparksPct = minSparksPct
    self.maxSparksPct = maxSparksPct
    self.minSparks = minSparks
    self.minMaxSparks = minMaxSparks
    self.freeplayTargetSparksTotal = freeplayTargetSparksTotal
    self.freeplayMinSparksRewardPct = freeplayMinSparksRewardPct
    self.freeplayMinSparksPct = freeplayMinSparksPct
    self.freeplayMaxSparksPct = freeplayMaxSparksPct
    self.freeplayMinSparks = freeplayMinSparks
    self.freeplayMinMaxSparks = freeplayMinMaxSparks

  @classmethod
  def unpack(cls, buffer):
    "Reads a new UnlockLevel from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('UnlockLevel.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new UnlockLevel from the given BinaryReader."
    _rewards = reader.read_object_varray(Anki.Cozmo.NeedsReward.unpack_from, 'B')
    _numStarsToUnlock = reader.read('i')
    _targetSparksTotal = reader.read('i')
    _maxPriorLevelUnlocks = reader.read('i')
    _minSparksPct = reader.read('f')
    _maxSparksPct = reader.read('f')
    _minSparks = reader.read('i')
    _minMaxSparks = reader.read('i')
    _freeplayTargetSparksTotal = reader.read('i')
    _freeplayMinSparksRewardPct = reader.read('f')
    _freeplayMinSparksPct = reader.read('f')
    _freeplayMaxSparksPct = reader.read('f')
    _freeplayMinSparks = reader.read('i')
    _freeplayMinMaxSparks = reader.read('i')
    return cls(_rewards, _numStarsToUnlock, _targetSparksTotal, _maxPriorLevelUnlocks, _minSparksPct, _maxSparksPct, _minSparks, _minMaxSparks, _freeplayTargetSparksTotal, _freeplayMinSparksRewardPct, _freeplayMinSparksPct, _freeplayMaxSparksPct, _freeplayMinSparks, _freeplayMinMaxSparks)

  def pack(self):
    "Writes the current UnlockLevel, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current UnlockLevel to the given BinaryWriter."
    writer.write_object_varray(self._rewards, 'B')
    writer.write(self._numStarsToUnlock, 'i')
    writer.write(self._targetSparksTotal, 'i')
    writer.write(self._maxPriorLevelUnlocks, 'i')
    writer.write(self._minSparksPct, 'f')
    writer.write(self._maxSparksPct, 'f')
    writer.write(self._minSparks, 'i')
    writer.write(self._minMaxSparks, 'i')
    writer.write(self._freeplayTargetSparksTotal, 'i')
    writer.write(self._freeplayMinSparksRewardPct, 'f')
    writer.write(self._freeplayMinSparksPct, 'f')
    writer.write(self._freeplayMaxSparksPct, 'f')
    writer.write(self._freeplayMinSparks, 'i')
    writer.write(self._freeplayMinMaxSparks, 'i')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._rewards == other._rewards and
        self._numStarsToUnlock == other._numStarsToUnlock and
        self._targetSparksTotal == other._targetSparksTotal and
        self._maxPriorLevelUnlocks == other._maxPriorLevelUnlocks and
        self._minSparksPct == other._minSparksPct and
        self._maxSparksPct == other._maxSparksPct and
        self._minSparks == other._minSparks and
        self._minMaxSparks == other._minMaxSparks and
        self._freeplayTargetSparksTotal == other._freeplayTargetSparksTotal and
        self._freeplayMinSparksRewardPct == other._freeplayMinSparksRewardPct and
        self._freeplayMinSparksPct == other._freeplayMinSparksPct and
        self._freeplayMaxSparksPct == other._freeplayMaxSparksPct and
        self._freeplayMinSparks == other._freeplayMinSparks and
        self._freeplayMinMaxSparks == other._freeplayMinMaxSparks)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_object_varray(self._rewards, 'B') +
      msgbuffers.size(self._numStarsToUnlock, 'i') +
      msgbuffers.size(self._targetSparksTotal, 'i') +
      msgbuffers.size(self._maxPriorLevelUnlocks, 'i') +
      msgbuffers.size(self._minSparksPct, 'f') +
      msgbuffers.size(self._maxSparksPct, 'f') +
      msgbuffers.size(self._minSparks, 'i') +
      msgbuffers.size(self._minMaxSparks, 'i') +
      msgbuffers.size(self._freeplayTargetSparksTotal, 'i') +
      msgbuffers.size(self._freeplayMinSparksRewardPct, 'f') +
      msgbuffers.size(self._freeplayMinSparksPct, 'f') +
      msgbuffers.size(self._freeplayMaxSparksPct, 'f') +
      msgbuffers.size(self._freeplayMinSparks, 'i') +
      msgbuffers.size(self._freeplayMinMaxSparks, 'i'))

  def __str__(self):
    return '{type}(rewards={rewards}, numStarsToUnlock={numStarsToUnlock}, targetSparksTotal={targetSparksTotal}, maxPriorLevelUnlocks={maxPriorLevelUnlocks}, minSparksPct={minSparksPct}, maxSparksPct={maxSparksPct}, minSparks={minSparks}, minMaxSparks={minMaxSparks}, freeplayTargetSparksTotal={freeplayTargetSparksTotal}, freeplayMinSparksRewardPct={freeplayMinSparksRewardPct}, freeplayMinSparksPct={freeplayMinSparksPct}, freeplayMaxSparksPct={freeplayMaxSparksPct}, freeplayMinSparks={freeplayMinSparks}, freeplayMinMaxSparks={freeplayMinMaxSparks})'.format(
      type=type(self).__name__,
      rewards=msgbuffers.shorten_sequence(self._rewards),
      numStarsToUnlock=self._numStarsToUnlock,
      targetSparksTotal=self._targetSparksTotal,
      maxPriorLevelUnlocks=self._maxPriorLevelUnlocks,
      minSparksPct=self._minSparksPct,
      maxSparksPct=self._maxSparksPct,
      minSparks=self._minSparks,
      minMaxSparks=self._minMaxSparks,
      freeplayTargetSparksTotal=self._freeplayTargetSparksTotal,
      freeplayMinSparksRewardPct=self._freeplayMinSparksRewardPct,
      freeplayMinSparksPct=self._freeplayMinSparksPct,
      freeplayMaxSparksPct=self._freeplayMaxSparksPct,
      freeplayMinSparks=self._freeplayMinSparks,
      freeplayMinMaxSparks=self._freeplayMinMaxSparks)

  def __repr__(self):
    return '{type}(rewards={rewards}, numStarsToUnlock={numStarsToUnlock}, targetSparksTotal={targetSparksTotal}, maxPriorLevelUnlocks={maxPriorLevelUnlocks}, minSparksPct={minSparksPct}, maxSparksPct={maxSparksPct}, minSparks={minSparks}, minMaxSparks={minMaxSparks}, freeplayTargetSparksTotal={freeplayTargetSparksTotal}, freeplayMinSparksRewardPct={freeplayMinSparksRewardPct}, freeplayMinSparksPct={freeplayMinSparksPct}, freeplayMaxSparksPct={freeplayMaxSparksPct}, freeplayMinSparks={freeplayMinSparks}, freeplayMinMaxSparks={freeplayMinMaxSparks})'.format(
      type=type(self).__name__,
      rewards=repr(self._rewards),
      numStarsToUnlock=repr(self._numStarsToUnlock),
      targetSparksTotal=repr(self._targetSparksTotal),
      maxPriorLevelUnlocks=repr(self._maxPriorLevelUnlocks),
      minSparksPct=repr(self._minSparksPct),
      maxSparksPct=repr(self._maxSparksPct),
      minSparks=repr(self._minSparks),
      minMaxSparks=repr(self._minMaxSparks),
      freeplayTargetSparksTotal=repr(self._freeplayTargetSparksTotal),
      freeplayMinSparksRewardPct=repr(self._freeplayMinSparksRewardPct),
      freeplayMinSparksPct=repr(self._freeplayMinSparksPct),
      freeplayMaxSparksPct=repr(self._freeplayMaxSparksPct),
      freeplayMinSparks=repr(self._freeplayMinSparks),
      freeplayMinMaxSparks=repr(self._freeplayMinMaxSparks))

Anki.Cozmo.UnlockLevel = UnlockLevel
del UnlockLevel


class NotificationType(object):
  "Automatically-generated int_32 enumeration."
  General           = 0
  NeedLevel         = 1
  NeedBracket       = 2
  DailyTokensToGo   = 3
  PostOnboarding    = 4
  TrickBased        = 5
  MinigamesUnlocked = 6

Anki.Cozmo.NotificationType = NotificationType
del NotificationType


class Connection(object):
  "Automatically-generated int_32 enumeration."
  Either        = 0
  DidConnect    = 1
  DidNotConnect = 2

Anki.Cozmo.Connection = Connection
del Connection


class TrickBasedParam(object):
  "Automatically-generated int_32 enumeration."
  LastUnlock = 1
  HasPlayed  = 2
  NotPlayed  = 3

Anki.Cozmo.TrickBasedParam = TrickBasedParam
del TrickBasedParam


class WhenType(object):
  "Automatically-generated int_32 enumeration."
  NotApplicable = 0
  AfterAppOpen  = 1
  AfterAppClose = 2
  ClockTime     = 3
  LocalDateTime = 4
  InstallDate   = 5
  AfterUnlock   = 6

Anki.Cozmo.WhenType = WhenType
del WhenType


class NotificationGeneral(object):
  "Generated message-passing structure."

  __slots__ = ()

  def __init__(self):
    pass

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NotificationGeneral from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NotificationGeneral.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NotificationGeneral from the given BinaryReader."
    return cls()

  def pack(self):
    "Writes the current NotificationGeneral, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NotificationGeneral to the given BinaryWriter."

  def __eq__(self, other):
    if type(self) is type(other):
      return True
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return 0

  def __str__(self):
    return '{type}()'.format(type=type(self).__name__)

  def __repr__(self):
    return '{type}()'.format(type=type(self).__name__)

Anki.Cozmo.NotificationGeneral = NotificationGeneral
del NotificationGeneral


class NotificationNeedLevel(object):
  "Generated message-passing structure."

  __slots__ = (
    '_needId', # Anki.Cozmo.NeedId
    '_level',  # float_32
  )

  @property
  def needId(self):
    "Anki.Cozmo.NeedId needId struct property."
    return self._needId

  @needId.setter
  def needId(self, value):
    self._needId = msgbuffers.validate_integer(
      'NotificationNeedLevel.needId', value, -2147483648, 2147483647)

  @property
  def level(self):
    "float_32 level struct property."
    return self._level

  @level.setter
  def level(self, value):
    self._level = msgbuffers.validate_float(
      'NotificationNeedLevel.level', value, 'f')

  def __init__(self, needId=Anki.Cozmo.NeedId.Repair, level=0.0):
    self.needId = needId
    self.level = level

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NotificationNeedLevel from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NotificationNeedLevel.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NotificationNeedLevel from the given BinaryReader."
    _needId = reader.read('i')
    _level = reader.read('f')
    return cls(_needId, _level)

  def pack(self):
    "Writes the current NotificationNeedLevel, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NotificationNeedLevel to the given BinaryWriter."
    writer.write(self._needId, 'i')
    writer.write(self._level, 'f')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._needId == other._needId and
        self._level == other._level)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._needId, 'i') +
      msgbuffers.size(self._level, 'f'))

  def __str__(self):
    return '{type}(needId={needId}, level={level})'.format(
      type=type(self).__name__,
      needId=self._needId,
      level=self._level)

  def __repr__(self):
    return '{type}(needId={needId}, level={level})'.format(
      type=type(self).__name__,
      needId=repr(self._needId),
      level=repr(self._level))

Anki.Cozmo.NotificationNeedLevel = NotificationNeedLevel
del NotificationNeedLevel


class NotificationNeedBracket(object):
  "Generated message-passing structure."

  __slots__ = (
    '_needId',        # Anki.Cozmo.NeedId
    '_needBracketId', # Anki.Cozmo.NeedBracketId
  )

  @property
  def needId(self):
    "Anki.Cozmo.NeedId needId struct property."
    return self._needId

  @needId.setter
  def needId(self, value):
    self._needId = msgbuffers.validate_integer(
      'NotificationNeedBracket.needId', value, -2147483648, 2147483647)

  @property
  def needBracketId(self):
    "Anki.Cozmo.NeedBracketId needBracketId struct property."
    return self._needBracketId

  @needBracketId.setter
  def needBracketId(self, value):
    self._needBracketId = msgbuffers.validate_integer(
      'NotificationNeedBracket.needBracketId', value, -2147483648, 2147483647)

  def __init__(self, needId=Anki.Cozmo.NeedId.Repair, needBracketId=Anki.Cozmo.NeedBracketId.Full):
    self.needId = needId
    self.needBracketId = needBracketId

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NotificationNeedBracket from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NotificationNeedBracket.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NotificationNeedBracket from the given BinaryReader."
    _needId = reader.read('i')
    _needBracketId = reader.read('i')
    return cls(_needId, _needBracketId)

  def pack(self):
    "Writes the current NotificationNeedBracket, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NotificationNeedBracket to the given BinaryWriter."
    writer.write(self._needId, 'i')
    writer.write(self._needBracketId, 'i')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._needId == other._needId and
        self._needBracketId == other._needBracketId)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._needId, 'i') +
      msgbuffers.size(self._needBracketId, 'i'))

  def __str__(self):
    return '{type}(needId={needId}, needBracketId={needBracketId})'.format(
      type=type(self).__name__,
      needId=self._needId,
      needBracketId=self._needBracketId)

  def __repr__(self):
    return '{type}(needId={needId}, needBracketId={needBracketId})'.format(
      type=type(self).__name__,
      needId=repr(self._needId),
      needBracketId=repr(self._needBracketId))

Anki.Cozmo.NotificationNeedBracket = NotificationNeedBracket
del NotificationNeedBracket


class NotificationDailyTokensToGo(object):
  "Generated message-passing structure."

  __slots__ = (
    '_numTokensToGo', # int_32
  )

  @property
  def numTokensToGo(self):
    "int_32 numTokensToGo struct property."
    return self._numTokensToGo

  @numTokensToGo.setter
  def numTokensToGo(self, value):
    self._numTokensToGo = msgbuffers.validate_integer(
      'NotificationDailyTokensToGo.numTokensToGo', value, -2147483648, 2147483647)

  def __init__(self, numTokensToGo=0):
    self.numTokensToGo = numTokensToGo

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NotificationDailyTokensToGo from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NotificationDailyTokensToGo.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NotificationDailyTokensToGo from the given BinaryReader."
    _numTokensToGo = reader.read('i')
    return cls(_numTokensToGo)

  def pack(self):
    "Writes the current NotificationDailyTokensToGo, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NotificationDailyTokensToGo to the given BinaryWriter."
    writer.write(self._numTokensToGo, 'i')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._numTokensToGo == other._numTokensToGo
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._numTokensToGo, 'i'))

  def __str__(self):
    return '{type}(numTokensToGo={numTokensToGo})'.format(
      type=type(self).__name__,
      numTokensToGo=self._numTokensToGo)

  def __repr__(self):
    return '{type}(numTokensToGo={numTokensToGo})'.format(
      type=type(self).__name__,
      numTokensToGo=repr(self._numTokensToGo))

Anki.Cozmo.NotificationDailyTokensToGo = NotificationDailyTokensToGo
del NotificationDailyTokensToGo


class NotificationPostOnboarding(object):
  "Generated message-passing structure."

  __slots__ = (
    '_numDaysStartAfter', # int_32
  )

  @property
  def numDaysStartAfter(self):
    "int_32 numDaysStartAfter struct property."
    return self._numDaysStartAfter

  @numDaysStartAfter.setter
  def numDaysStartAfter(self, value):
    self._numDaysStartAfter = msgbuffers.validate_integer(
      'NotificationPostOnboarding.numDaysStartAfter', value, -2147483648, 2147483647)

  def __init__(self, numDaysStartAfter=0):
    self.numDaysStartAfter = numDaysStartAfter

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NotificationPostOnboarding from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NotificationPostOnboarding.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NotificationPostOnboarding from the given BinaryReader."
    _numDaysStartAfter = reader.read('i')
    return cls(_numDaysStartAfter)

  def pack(self):
    "Writes the current NotificationPostOnboarding, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NotificationPostOnboarding to the given BinaryWriter."
    writer.write(self._numDaysStartAfter, 'i')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._numDaysStartAfter == other._numDaysStartAfter
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._numDaysStartAfter, 'i'))

  def __str__(self):
    return '{type}(numDaysStartAfter={numDaysStartAfter})'.format(
      type=type(self).__name__,
      numDaysStartAfter=self._numDaysStartAfter)

  def __repr__(self):
    return '{type}(numDaysStartAfter={numDaysStartAfter})'.format(
      type=type(self).__name__,
      numDaysStartAfter=repr(self._numDaysStartAfter))

Anki.Cozmo.NotificationPostOnboarding = NotificationPostOnboarding
del NotificationPostOnboarding


class NotificationTrickBased(object):
  "Generated message-passing structure."

  __slots__ = (
    '_trickUnlockId',  # Anki.Cozmo.UnlockId
    '_comparisonType', # Anki.Cozmo.TrickBasedParam
  )

  @property
  def trickUnlockId(self):
    "Anki.Cozmo.UnlockId trickUnlockId struct property."
    return self._trickUnlockId

  @trickUnlockId.setter
  def trickUnlockId(self, value):
    self._trickUnlockId = msgbuffers.validate_integer(
      'NotificationTrickBased.trickUnlockId', value, -2147483648, 2147483647)

  @property
  def comparisonType(self):
    "Anki.Cozmo.TrickBasedParam comparisonType struct property."
    return self._comparisonType

  @comparisonType.setter
  def comparisonType(self, value):
    self._comparisonType = msgbuffers.validate_integer(
      'NotificationTrickBased.comparisonType', value, -2147483648, 2147483647)

  def __init__(self, trickUnlockId=Anki.Cozmo.UnlockId.Invalid, comparisonType=Anki.Cozmo.TrickBasedParam.LastUnlock):
    self.trickUnlockId = trickUnlockId
    self.comparisonType = comparisonType

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NotificationTrickBased from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NotificationTrickBased.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NotificationTrickBased from the given BinaryReader."
    _trickUnlockId = reader.read('i')
    _comparisonType = reader.read('i')
    return cls(_trickUnlockId, _comparisonType)

  def pack(self):
    "Writes the current NotificationTrickBased, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NotificationTrickBased to the given BinaryWriter."
    writer.write(self._trickUnlockId, 'i')
    writer.write(self._comparisonType, 'i')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._trickUnlockId == other._trickUnlockId and
        self._comparisonType == other._comparisonType)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._trickUnlockId, 'i') +
      msgbuffers.size(self._comparisonType, 'i'))

  def __str__(self):
    return '{type}(trickUnlockId={trickUnlockId}, comparisonType={comparisonType})'.format(
      type=type(self).__name__,
      trickUnlockId=self._trickUnlockId,
      comparisonType=self._comparisonType)

  def __repr__(self):
    return '{type}(trickUnlockId={trickUnlockId}, comparisonType={comparisonType})'.format(
      type=type(self).__name__,
      trickUnlockId=repr(self._trickUnlockId),
      comparisonType=repr(self._comparisonType))

Anki.Cozmo.NotificationTrickBased = NotificationTrickBased
del NotificationTrickBased


class NotificationMinigamesUnlocked(object):
  "Generated message-passing structure."

  __slots__ = (
    '_minigamesUnlocked', # bool
  )

  @property
  def minigamesUnlocked(self):
    "bool minigamesUnlocked struct property."
    return self._minigamesUnlocked

  @minigamesUnlocked.setter
  def minigamesUnlocked(self, value):
    self._minigamesUnlocked = msgbuffers.validate_bool(
      'NotificationMinigamesUnlocked.minigamesUnlocked', value)

  def __init__(self, minigamesUnlocked=False):
    self.minigamesUnlocked = minigamesUnlocked

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NotificationMinigamesUnlocked from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NotificationMinigamesUnlocked.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NotificationMinigamesUnlocked from the given BinaryReader."
    _minigamesUnlocked = bool(reader.read('b'))
    return cls(_minigamesUnlocked)

  def pack(self):
    "Writes the current NotificationMinigamesUnlocked, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current NotificationMinigamesUnlocked to the given BinaryWriter."
    writer.write(int(self._minigamesUnlocked), 'b')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._minigamesUnlocked == other._minigamesUnlocked
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._minigamesUnlocked, 'b'))

  def __str__(self):
    return '{type}(minigamesUnlocked={minigamesUnlocked})'.format(
      type=type(self).__name__,
      minigamesUnlocked=self._minigamesUnlocked)

  def __repr__(self):
    return '{type}(minigamesUnlocked={minigamesUnlocked})'.format(
      type=type(self).__name__,
      minigamesUnlocked=repr(self._minigamesUnlocked))

Anki.Cozmo.NotificationMinigamesUnlocked = NotificationMinigamesUnlocked
del NotificationMinigamesUnlocked


class NotificationUnion(object):
  "Generated message-passing union."

  __slots__ = ('_tag', '_data')

  class Tag(object):
    "The type indicator for this union."
    notificationGeneral           = 0 # Anki.Cozmo.NotificationGeneral
    notificationNeedLevel         = 1 # Anki.Cozmo.NotificationNeedLevel
    notificationNeedBracket       = 2 # Anki.Cozmo.NotificationNeedBracket
    notificationDailyTokensToGo   = 3 # Anki.Cozmo.NotificationDailyTokensToGo
    notificationPostOnboarding    = 4 # Anki.Cozmo.NotificationPostOnboarding
    notificationTrickBased        = 5 # Anki.Cozmo.NotificationTrickBased
    notificationMinigamesUnlocked = 6 # Anki.Cozmo.NotificationMinigamesUnlocked

  @property
  def tag(self):
    "The current tag for this union."
    return self._tag

  @property
  def tag_name(self):
    "The name of the current tag for this union."
    if self._tag in self._tags_by_value:
      return self._tags_by_value[self._tag]
    else:
      return None

  @property
  def data(self):
    "The data held by this union. None if no data is set."
    return self._data

  @property
  def notificationGeneral(self):
    "Anki.Cozmo.NotificationGeneral notificationGeneral union property."
    msgbuffers.safety_check_tag('notificationGeneral', self._tag, self.Tag.notificationGeneral, self._tags_by_value)
    return self._data

  @notificationGeneral.setter
  def notificationGeneral(self, value):
    self._data = msgbuffers.validate_object(
      'NotificationUnion.notificationGeneral', value, Anki.Cozmo.NotificationGeneral)
    self._tag = self.Tag.notificationGeneral

  @property
  def notificationNeedLevel(self):
    "Anki.Cozmo.NotificationNeedLevel notificationNeedLevel union property."
    msgbuffers.safety_check_tag('notificationNeedLevel', self._tag, self.Tag.notificationNeedLevel, self._tags_by_value)
    return self._data

  @notificationNeedLevel.setter
  def notificationNeedLevel(self, value):
    self._data = msgbuffers.validate_object(
      'NotificationUnion.notificationNeedLevel', value, Anki.Cozmo.NotificationNeedLevel)
    self._tag = self.Tag.notificationNeedLevel

  @property
  def notificationNeedBracket(self):
    "Anki.Cozmo.NotificationNeedBracket notificationNeedBracket union property."
    msgbuffers.safety_check_tag('notificationNeedBracket', self._tag, self.Tag.notificationNeedBracket, self._tags_by_value)
    return self._data

  @notificationNeedBracket.setter
  def notificationNeedBracket(self, value):
    self._data = msgbuffers.validate_object(
      'NotificationUnion.notificationNeedBracket', value, Anki.Cozmo.NotificationNeedBracket)
    self._tag = self.Tag.notificationNeedBracket

  @property
  def notificationDailyTokensToGo(self):
    "Anki.Cozmo.NotificationDailyTokensToGo notificationDailyTokensToGo union property."
    msgbuffers.safety_check_tag('notificationDailyTokensToGo', self._tag, self.Tag.notificationDailyTokensToGo, self._tags_by_value)
    return self._data

  @notificationDailyTokensToGo.setter
  def notificationDailyTokensToGo(self, value):
    self._data = msgbuffers.validate_object(
      'NotificationUnion.notificationDailyTokensToGo', value, Anki.Cozmo.NotificationDailyTokensToGo)
    self._tag = self.Tag.notificationDailyTokensToGo

  @property
  def notificationPostOnboarding(self):
    "Anki.Cozmo.NotificationPostOnboarding notificationPostOnboarding union property."
    msgbuffers.safety_check_tag('notificationPostOnboarding', self._tag, self.Tag.notificationPostOnboarding, self._tags_by_value)
    return self._data

  @notificationPostOnboarding.setter
  def notificationPostOnboarding(self, value):
    self._data = msgbuffers.validate_object(
      'NotificationUnion.notificationPostOnboarding', value, Anki.Cozmo.NotificationPostOnboarding)
    self._tag = self.Tag.notificationPostOnboarding

  @property
  def notificationTrickBased(self):
    "Anki.Cozmo.NotificationTrickBased notificationTrickBased union property."
    msgbuffers.safety_check_tag('notificationTrickBased', self._tag, self.Tag.notificationTrickBased, self._tags_by_value)
    return self._data

  @notificationTrickBased.setter
  def notificationTrickBased(self, value):
    self._data = msgbuffers.validate_object(
      'NotificationUnion.notificationTrickBased', value, Anki.Cozmo.NotificationTrickBased)
    self._tag = self.Tag.notificationTrickBased

  @property
  def notificationMinigamesUnlocked(self):
    "Anki.Cozmo.NotificationMinigamesUnlocked notificationMinigamesUnlocked union property."
    msgbuffers.safety_check_tag('notificationMinigamesUnlocked', self._tag, self.Tag.notificationMinigamesUnlocked, self._tags_by_value)
    return self._data

  @notificationMinigamesUnlocked.setter
  def notificationMinigamesUnlocked(self, value):
    self._data = msgbuffers.validate_object(
      'NotificationUnion.notificationMinigamesUnlocked', value, Anki.Cozmo.NotificationMinigamesUnlocked)
    self._tag = self.Tag.notificationMinigamesUnlocked

  def __init__(self, **kwargs):
    if not kwargs:
      self._tag = None
      self._data = None

    elif len(kwargs) == 1:
      key, value = next(iter(kwargs.items()))
      if key not in self._tags_by_name:
        raise TypeError("'{argument}' is an invalid keyword argument for this method.".format(argument=key))
      # calls the correct property
      setattr(self, key, value)

    else:
      raise TypeError('This method only accepts up to one keyword argument.')

  @classmethod
  def unpack(cls, buffer):
    "Reads a new NotificationUnion from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('NotificationUnion.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new NotificationUnion from the given BinaryReader."
    tag = reader.read('B')
    if tag in cls._tags_by_value:
      value = cls()
      setattr(value, cls._tags_by_value[tag], cls._tag_unpack_methods[tag](reader))
      return value
    else:
      raise ValueError('NotificationUnion attempted to unpack unknown tag {tag}.'.format(tag=tag))

  def pack(self):
    "Writes the current NotificationUnion, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current SampleUnion to the given BinaryWriter."
    if self._tag in self._tags_by_value:
      writer.write(self._tag, 'B')
      self._tag_pack_methods[self._tag](writer, self._data)
    else:
      raise ValueError('Cannot pack an empty NotificationUnion.')

  def clear(self):
    self._tag = None
    self._data = None

  @classmethod
  def typeByTag(cls, tag):
    return cls._type_by_tag_value[tag]()

  def __eq__(self, other):
    if type(self) is type(other):
      return self._tag == other._tag and self._data == other._data
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    if 0 <= self._tag < 7:
      return self._tag_size_methods[self._tag](self._data)
    else:
      return 1

  def __str__(self):
    if 0 <= self._tag < 7:
      return '{type}({name}={value})'.format(
        type=type(self).__name__,
        name=self.tag_name,
        value=self._data)
    else:
      return '{type}()'.format(
        type=type(self).__name__)

  def __repr__(self):
    if 0 <= self._tag < 7:
      return '{type}({name}={value})'.format(
        type=type(self).__name__,
        name=self.tag_name,
        value=repr(self._data))
    else:
      return '{type}()'.format(
        type=type(self).__name__)

  _tags_by_name = dict(
    notificationGeneral=0,
    notificationNeedLevel=1,
    notificationNeedBracket=2,
    notificationDailyTokensToGo=3,
    notificationPostOnboarding=4,
    notificationTrickBased=5,
    notificationMinigamesUnlocked=6,
  )

  _tags_by_value = dict()
  _tags_by_value[0] = 'notificationGeneral'
  _tags_by_value[1] = 'notificationNeedLevel'
  _tags_by_value[2] = 'notificationNeedBracket'
  _tags_by_value[3] = 'notificationDailyTokensToGo'
  _tags_by_value[4] = 'notificationPostOnboarding'
  _tags_by_value[5] = 'notificationTrickBased'
  _tags_by_value[6] = 'notificationMinigamesUnlocked'
  

  _tag_unpack_methods = dict()
  _tag_unpack_methods[0] = lambda reader: reader.read_object(Anki.Cozmo.NotificationGeneral.unpack_from)
  _tag_unpack_methods[1] = lambda reader: reader.read_object(Anki.Cozmo.NotificationNeedLevel.unpack_from)
  _tag_unpack_methods[2] = lambda reader: reader.read_object(Anki.Cozmo.NotificationNeedBracket.unpack_from)
  _tag_unpack_methods[3] = lambda reader: reader.read_object(Anki.Cozmo.NotificationDailyTokensToGo.unpack_from)
  _tag_unpack_methods[4] = lambda reader: reader.read_object(Anki.Cozmo.NotificationPostOnboarding.unpack_from)
  _tag_unpack_methods[5] = lambda reader: reader.read_object(Anki.Cozmo.NotificationTrickBased.unpack_from)
  _tag_unpack_methods[6] = lambda reader: reader.read_object(Anki.Cozmo.NotificationMinigamesUnlocked.unpack_from)
  

  _tag_pack_methods = dict()
  _tag_pack_methods[0] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[1] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[2] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[3] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[4] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[5] = lambda writer, value: writer.write_object(value)
  _tag_pack_methods[6] = lambda writer, value: writer.write_object(value)
  

  _tag_size_methods = dict()
  _tag_size_methods[0] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[1] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[2] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[3] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[4] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[5] = lambda value: msgbuffers.size_object(value)
  _tag_size_methods[6] = lambda value: msgbuffers.size_object(value)
  

  _type_by_tag_value = dict()
  _type_by_tag_value[0] = lambda : Anki.Cozmo.NotificationGeneral
  _type_by_tag_value[1] = lambda : Anki.Cozmo.NotificationNeedLevel
  _type_by_tag_value[2] = lambda : Anki.Cozmo.NotificationNeedBracket
  _type_by_tag_value[3] = lambda : Anki.Cozmo.NotificationDailyTokensToGo
  _type_by_tag_value[4] = lambda : Anki.Cozmo.NotificationPostOnboarding
  _type_by_tag_value[5] = lambda : Anki.Cozmo.NotificationTrickBased
  _type_by_tag_value[6] = lambda : Anki.Cozmo.NotificationMinigamesUnlocked
  

Anki.Cozmo.NotificationUnion = NotificationUnion
del NotificationUnion


class LocalNotificationItem(object):
  "Generated message-passing structure."

  __slots__ = (
    '_notificationMainUnion', # Anki.Cozmo.NotificationUnion
    '_connection',            # Anki.Cozmo.Connection
    '_titleKey',              # string[uint_8]
    '_textKeys',              # string[uint_8][uint_8]
    '_whenType',              # Anki.Cozmo.WhenType
    '_whenParam',             # string[uint_8]
    '_rangeEarly',            # float_32
    '_rangeLate',             # float_32
    '_minimumDuration',       # float_32
    '_noEarlierThan',         # float_32
    '_noLaterThan',           # float_32
    '_deeplinkCodeLab',       # string[uint_8]
    '_webpageURL',            # string[uint_8]
  )

  @property
  def notificationMainUnion(self):
    "Anki.Cozmo.NotificationUnion notificationMainUnion struct property."
    return self._notificationMainUnion

  @notificationMainUnion.setter
  def notificationMainUnion(self, value):
    self._notificationMainUnion = msgbuffers.validate_object(
      'LocalNotificationItem.notificationMainUnion', value, Anki.Cozmo.NotificationUnion)

  @property
  def connection(self):
    "Anki.Cozmo.Connection connection struct property."
    return self._connection

  @connection.setter
  def connection(self, value):
    self._connection = msgbuffers.validate_integer(
      'LocalNotificationItem.connection', value, -2147483648, 2147483647)

  @property
  def titleKey(self):
    "string[uint_8] titleKey struct property."
    return self._titleKey

  @titleKey.setter
  def titleKey(self, value):
    self._titleKey = msgbuffers.validate_string(
      'LocalNotificationItem.titleKey', value, 255)

  @property
  def textKeys(self):
    "string[uint_8][uint_8] textKeys struct property."
    return self._textKeys

  @textKeys.setter
  def textKeys(self, value):
    self._textKeys = msgbuffers.validate_varray(
      'LocalNotificationItem.textKeys', value, 255,
      lambda name, value_inner: msgbuffers.validate_string(
        name, value_inner, 255))

  @property
  def whenType(self):
    "Anki.Cozmo.WhenType whenType struct property."
    return self._whenType

  @whenType.setter
  def whenType(self, value):
    self._whenType = msgbuffers.validate_integer(
      'LocalNotificationItem.whenType', value, -2147483648, 2147483647)

  @property
  def whenParam(self):
    "string[uint_8] whenParam struct property."
    return self._whenParam

  @whenParam.setter
  def whenParam(self, value):
    self._whenParam = msgbuffers.validate_string(
      'LocalNotificationItem.whenParam', value, 255)

  @property
  def rangeEarly(self):
    "float_32 rangeEarly struct property."
    return self._rangeEarly

  @rangeEarly.setter
  def rangeEarly(self, value):
    self._rangeEarly = msgbuffers.validate_float(
      'LocalNotificationItem.rangeEarly', value, 'f')

  @property
  def rangeLate(self):
    "float_32 rangeLate struct property."
    return self._rangeLate

  @rangeLate.setter
  def rangeLate(self, value):
    self._rangeLate = msgbuffers.validate_float(
      'LocalNotificationItem.rangeLate', value, 'f')

  @property
  def minimumDuration(self):
    "float_32 minimumDuration struct property."
    return self._minimumDuration

  @minimumDuration.setter
  def minimumDuration(self, value):
    self._minimumDuration = msgbuffers.validate_float(
      'LocalNotificationItem.minimumDuration', value, 'f')

  @property
  def noEarlierThan(self):
    "float_32 noEarlierThan struct property."
    return self._noEarlierThan

  @noEarlierThan.setter
  def noEarlierThan(self, value):
    self._noEarlierThan = msgbuffers.validate_float(
      'LocalNotificationItem.noEarlierThan', value, 'f')

  @property
  def noLaterThan(self):
    "float_32 noLaterThan struct property."
    return self._noLaterThan

  @noLaterThan.setter
  def noLaterThan(self, value):
    self._noLaterThan = msgbuffers.validate_float(
      'LocalNotificationItem.noLaterThan', value, 'f')

  @property
  def deeplinkCodeLab(self):
    "string[uint_8] deeplinkCodeLab struct property."
    return self._deeplinkCodeLab

  @deeplinkCodeLab.setter
  def deeplinkCodeLab(self, value):
    self._deeplinkCodeLab = msgbuffers.validate_string(
      'LocalNotificationItem.deeplinkCodeLab', value, 255)

  @property
  def webpageURL(self):
    "string[uint_8] webpageURL struct property."
    return self._webpageURL

  @webpageURL.setter
  def webpageURL(self, value):
    self._webpageURL = msgbuffers.validate_string(
      'LocalNotificationItem.webpageURL', value, 255)

  def __init__(self, notificationMainUnion=Anki.Cozmo.NotificationUnion(), connection=Anki.Cozmo.Connection.Either, titleKey='', textKeys=(), whenType=Anki.Cozmo.WhenType.NotApplicable, whenParam='', rangeEarly=0.0, rangeLate=0.0, minimumDuration=0.0, noEarlierThan=0.0, noLaterThan=0.0, deeplinkCodeLab='', webpageURL=''):
    self.notificationMainUnion = notificationMainUnion
    self.connection = connection
    self.titleKey = titleKey
    self.textKeys = textKeys
    self.whenType = whenType
    self.whenParam = whenParam
    self.rangeEarly = rangeEarly
    self.rangeLate = rangeLate
    self.minimumDuration = minimumDuration
    self.noEarlierThan = noEarlierThan
    self.noLaterThan = noLaterThan
    self.deeplinkCodeLab = deeplinkCodeLab
    self.webpageURL = webpageURL

  @classmethod
  def unpack(cls, buffer):
    "Reads a new LocalNotificationItem from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('LocalNotificationItem.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new LocalNotificationItem from the given BinaryReader."
    _notificationMainUnion = reader.read_object(Anki.Cozmo.NotificationUnion.unpack_from)
    _connection = reader.read('i')
    _titleKey = reader.read_string('B')
    _textKeys = reader.read_string_varray('B', 'B')
    _whenType = reader.read('i')
    _whenParam = reader.read_string('B')
    _rangeEarly = reader.read('f')
    _rangeLate = reader.read('f')
    _minimumDuration = reader.read('f')
    _noEarlierThan = reader.read('f')
    _noLaterThan = reader.read('f')
    _deeplinkCodeLab = reader.read_string('B')
    _webpageURL = reader.read_string('B')
    return cls(_notificationMainUnion, _connection, _titleKey, _textKeys, _whenType, _whenParam, _rangeEarly, _rangeLate, _minimumDuration, _noEarlierThan, _noLaterThan, _deeplinkCodeLab, _webpageURL)

  def pack(self):
    "Writes the current LocalNotificationItem, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current LocalNotificationItem to the given BinaryWriter."
    writer.write_object(self._notificationMainUnion)
    writer.write(self._connection, 'i')
    writer.write_string(self._titleKey, 'B')
    writer.write_string_varray(self._textKeys, 'B', 'B')
    writer.write(self._whenType, 'i')
    writer.write_string(self._whenParam, 'B')
    writer.write(self._rangeEarly, 'f')
    writer.write(self._rangeLate, 'f')
    writer.write(self._minimumDuration, 'f')
    writer.write(self._noEarlierThan, 'f')
    writer.write(self._noLaterThan, 'f')
    writer.write_string(self._deeplinkCodeLab, 'B')
    writer.write_string(self._webpageURL, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._notificationMainUnion == other._notificationMainUnion and
        self._connection == other._connection and
        self._titleKey == other._titleKey and
        self._textKeys == other._textKeys and
        self._whenType == other._whenType and
        self._whenParam == other._whenParam and
        self._rangeEarly == other._rangeEarly and
        self._rangeLate == other._rangeLate and
        self._minimumDuration == other._minimumDuration and
        self._noEarlierThan == other._noEarlierThan and
        self._noLaterThan == other._noLaterThan and
        self._deeplinkCodeLab == other._deeplinkCodeLab and
        self._webpageURL == other._webpageURL)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_object(self._notificationMainUnion) +
      msgbuffers.size(self._connection, 'i') +
      msgbuffers.size_string(self._titleKey, 'B') +
      msgbuffers.size_string_varray(self._textKeys, 'B', 'B') +
      msgbuffers.size(self._whenType, 'i') +
      msgbuffers.size_string(self._whenParam, 'B') +
      msgbuffers.size(self._rangeEarly, 'f') +
      msgbuffers.size(self._rangeLate, 'f') +
      msgbuffers.size(self._minimumDuration, 'f') +
      msgbuffers.size(self._noEarlierThan, 'f') +
      msgbuffers.size(self._noLaterThan, 'f') +
      msgbuffers.size_string(self._deeplinkCodeLab, 'B') +
      msgbuffers.size_string(self._webpageURL, 'B'))

  def __str__(self):
    return '{type}(notificationMainUnion={notificationMainUnion}, connection={connection}, titleKey={titleKey}, textKeys={textKeys}, whenType={whenType}, whenParam={whenParam}, rangeEarly={rangeEarly}, rangeLate={rangeLate}, minimumDuration={minimumDuration}, noEarlierThan={noEarlierThan}, noLaterThan={noLaterThan}, deeplinkCodeLab={deeplinkCodeLab}, webpageURL={webpageURL})'.format(
      type=type(self).__name__,
      notificationMainUnion=self._notificationMainUnion,
      connection=self._connection,
      titleKey=msgbuffers.shorten_string(self._titleKey),
      textKeys=msgbuffers.shorten_sequence(self._textKeys, msgbuffers.shorten_string),
      whenType=self._whenType,
      whenParam=msgbuffers.shorten_string(self._whenParam),
      rangeEarly=self._rangeEarly,
      rangeLate=self._rangeLate,
      minimumDuration=self._minimumDuration,
      noEarlierThan=self._noEarlierThan,
      noLaterThan=self._noLaterThan,
      deeplinkCodeLab=msgbuffers.shorten_string(self._deeplinkCodeLab),
      webpageURL=msgbuffers.shorten_string(self._webpageURL))

  def __repr__(self):
    return '{type}(notificationMainUnion={notificationMainUnion}, connection={connection}, titleKey={titleKey}, textKeys={textKeys}, whenType={whenType}, whenParam={whenParam}, rangeEarly={rangeEarly}, rangeLate={rangeLate}, minimumDuration={minimumDuration}, noEarlierThan={noEarlierThan}, noLaterThan={noLaterThan}, deeplinkCodeLab={deeplinkCodeLab}, webpageURL={webpageURL})'.format(
      type=type(self).__name__,
      notificationMainUnion=repr(self._notificationMainUnion),
      connection=repr(self._connection),
      titleKey=repr(self._titleKey),
      textKeys=repr(self._textKeys),
      whenType=repr(self._whenType),
      whenParam=repr(self._whenParam),
      rangeEarly=repr(self._rangeEarly),
      rangeLate=repr(self._rangeLate),
      minimumDuration=repr(self._minimumDuration),
      noEarlierThan=repr(self._noEarlierThan),
      noLaterThan=repr(self._noLaterThan),
      deeplinkCodeLab=repr(self._deeplinkCodeLab),
      webpageURL=repr(self._webpageURL))

Anki.Cozmo.LocalNotificationItem = LocalNotificationItem
del LocalNotificationItem


class LocalNotificationConfig(object):
  "Generated message-passing structure."

  __slots__ = (
    '_items', # LocalNotificationItem[uint_16]
  )

  @property
  def items(self):
    "LocalNotificationItem[uint_16] items struct property."
    return self._items

  @items.setter
  def items(self, value):
    self._items = msgbuffers.validate_varray(
      'LocalNotificationConfig.items', value, 65535,
      lambda name, value_inner: msgbuffers.validate_object(
        name, value_inner, Anki.Cozmo.LocalNotificationItem))

  def __init__(self, items=()):
    self.items = items

  @classmethod
  def unpack(cls, buffer):
    "Reads a new LocalNotificationConfig from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('LocalNotificationConfig.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new LocalNotificationConfig from the given BinaryReader."
    _items = reader.read_object_varray(Anki.Cozmo.LocalNotificationItem.unpack_from, 'H')
    return cls(_items)

  def pack(self):
    "Writes the current LocalNotificationConfig, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current LocalNotificationConfig to the given BinaryWriter."
    writer.write_object_varray(self._items, 'H')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._items == other._items
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_object_varray(self._items, 'H'))

  def __str__(self):
    return '{type}(items={items})'.format(
      type=type(self).__name__,
      items=msgbuffers.shorten_sequence(self._items))

  def __repr__(self):
    return '{type}(items={items})'.format(
      type=type(self).__name__,
      items=repr(self._items))

Anki.Cozmo.LocalNotificationConfig = LocalNotificationConfig
del LocalNotificationConfig


class LabAssignment(object):
  "Generated message-passing structure."

  __slots__ = (
    '_experiment_key', # string[uint_8]
    '_variation_key',  # string[uint_8]
  )

  @property
  def experiment_key(self):
    "string[uint_8] experiment_key struct property."
    return self._experiment_key

  @experiment_key.setter
  def experiment_key(self, value):
    self._experiment_key = msgbuffers.validate_string(
      'LabAssignment.experiment_key', value, 255)

  @property
  def variation_key(self):
    "string[uint_8] variation_key struct property."
    return self._variation_key

  @variation_key.setter
  def variation_key(self, value):
    self._variation_key = msgbuffers.validate_string(
      'LabAssignment.variation_key', value, 255)

  def __init__(self, experiment_key='', variation_key=''):
    self.experiment_key = experiment_key
    self.variation_key = variation_key

  @classmethod
  def unpack(cls, buffer):
    "Reads a new LabAssignment from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('LabAssignment.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new LabAssignment from the given BinaryReader."
    _experiment_key = reader.read_string('B')
    _variation_key = reader.read_string('B')
    return cls(_experiment_key, _variation_key)

  def pack(self):
    "Writes the current LabAssignment, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current LabAssignment to the given BinaryWriter."
    writer.write_string(self._experiment_key, 'B')
    writer.write_string(self._variation_key, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._experiment_key == other._experiment_key and
        self._variation_key == other._variation_key)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_string(self._experiment_key, 'B') +
      msgbuffers.size_string(self._variation_key, 'B'))

  def __str__(self):
    return '{type}(experiment_key={experiment_key}, variation_key={variation_key})'.format(
      type=type(self).__name__,
      experiment_key=msgbuffers.shorten_string(self._experiment_key),
      variation_key=msgbuffers.shorten_string(self._variation_key))

  def __repr__(self):
    return '{type}(experiment_key={experiment_key}, variation_key={variation_key})'.format(
      type=type(self).__name__,
      experiment_key=repr(self._experiment_key),
      variation_key=repr(self._variation_key))

Anki.Cozmo.LabAssignment = LabAssignment
del LabAssignment


class LabAssignments(object):
  "Generated message-passing structure."

  __slots__ = (
    '_labAssignments', # LabAssignment[uint_8]
  )

  @property
  def labAssignments(self):
    "LabAssignment[uint_8] labAssignments struct property."
    return self._labAssignments

  @labAssignments.setter
  def labAssignments(self, value):
    self._labAssignments = msgbuffers.validate_varray(
      'LabAssignments.labAssignments', value, 255,
      lambda name, value_inner: msgbuffers.validate_object(
        name, value_inner, Anki.Cozmo.LabAssignment))

  def __init__(self, labAssignments=()):
    self.labAssignments = labAssignments

  @classmethod
  def unpack(cls, buffer):
    "Reads a new LabAssignments from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('LabAssignments.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new LabAssignments from the given BinaryReader."
    _labAssignments = reader.read_object_varray(Anki.Cozmo.LabAssignment.unpack_from, 'B')
    return cls(_labAssignments)

  def pack(self):
    "Writes the current LabAssignments, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current LabAssignments to the given BinaryWriter."
    writer.write_object_varray(self._labAssignments, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._labAssignments == other._labAssignments
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_object_varray(self._labAssignments, 'B'))

  def __str__(self):
    return '{type}(labAssignments={labAssignments})'.format(
      type=type(self).__name__,
      labAssignments=msgbuffers.shorten_sequence(self._labAssignments))

  def __repr__(self):
    return '{type}(labAssignments={labAssignments})'.format(
      type=type(self).__name__,
      labAssignments=repr(self._labAssignments))

Anki.Cozmo.LabAssignments = LabAssignments
del LabAssignments


