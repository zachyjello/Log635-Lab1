# Copyright (c) 2016-2017 Anki, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License in the file LICENSE.txt or at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Autogenerated python message buffer code.
Source: clad/robotInterface/bleMessages.clad
Full command line: ../tools/message-buffers/emitters/Python_emitter.py -C ../robot/clad/src/ -o ../generated/cladPython// clad/robotInterface/bleMessages.clad
"""

from __future__ import absolute_import
from __future__ import print_function

def _modify_path():
  import inspect, os, sys
  search_paths = [
    '../..',
    '../../../../tools/message-buffers/support/python',
  ]
  currentpath = os.path.abspath(os.path.dirname(inspect.getfile(inspect.currentframe())))
  for search_path in search_paths:
    search_path = os.path.normpath(os.path.abspath(os.path.realpath(os.path.join(currentpath, search_path))))
    if search_path not in sys.path:
      sys.path.insert(0, search_path)
_modify_path()

import msgbuffers

Anki = msgbuffers.Namespace()
Anki.Cozmo = msgbuffers.Namespace()
Anki.Cozmo.BLE = msgbuffers.Namespace()

class BluetoothConstants(object):
  "Automatically-generated uint_32 enumeration."
  COZMO_FRAME_DATA_LENGTH = 16

Anki.Cozmo.BLE.BluetoothConstants = BluetoothConstants
del BluetoothConstants


class BluetoothConnectionState(object):
  "Automatically-generated uint_32 enumeration."
  BLE_CONNECTED                    = 0
  BLE_DISCONNECTED_NORMALLY        = 1
  BLE_CANNOT_CONFIGURE_CONN_PARAMS = 2

Anki.Cozmo.BLE.BluetoothConnectionState = BluetoothConnectionState
del BluetoothConnectionState


class PayloadFlags(object):
  "Automatically-generated uint_8 enumeration."
  START_OF_MESSAGE  = 1
  END_OF_MESSAGE    = 2
  MESSAGE_ENCRYPTED = 4

Anki.Cozmo.BLE.PayloadFlags = PayloadFlags
del PayloadFlags


class Frame(object):
  "Generated message-passing structure."

  __slots__ = (
    '_flags', # uint_8
    '_data',  # uint_8[16]
  )

  @property
  def flags(self):
    "uint_8 flags struct property."
    return self._flags

  @flags.setter
  def flags(self, value):
    self._flags = msgbuffers.validate_integer(
      'Frame.flags', value, 0, 255)

  @property
  def data(self):
    "uint_8[16] data struct property."
    return self._data

  @data.setter
  def data(self, value):
    self._data = msgbuffers.validate_farray(
      'Frame.data', value, 16,
      lambda name, value_inner: msgbuffers.validate_integer(
        name, value_inner, 0, 255))

  def __init__(self, flags=0, data=(0,) * 16):
    self.flags = flags
    self.data = data

  @classmethod
  def unpack(cls, buffer):
    "Reads a new Frame from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('Frame.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new Frame from the given BinaryReader."
    _flags = reader.read('B')
    _data = reader.read_farray('B', 16)
    return cls(_flags, _data)

  def pack(self):
    "Writes the current Frame, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current Frame to the given BinaryWriter."
    writer.write(self._flags, 'B')
    writer.write_farray(self._data, 'B', 16)

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._flags == other._flags and
        self._data == other._data)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._flags, 'B') +
      msgbuffers.size_farray(self._data, 'B', 16))

  def __str__(self):
    return '{type}(flags={flags}, data={data})'.format(
      type=type(self).__name__,
      flags=self._flags,
      data=msgbuffers.shorten_sequence(self._data))

  def __repr__(self):
    return '{type}(flags={flags}, data={data})'.format(
      type=type(self).__name__,
      flags=repr(self._flags),
      data=repr(self._data))

Anki.Cozmo.BLE.Frame = Frame
del Frame


class Disconnect(object):
  "Generated message-passing message."

  __slots__ = (
    '_reason', # uint_32
  )

  @property
  def reason(self):
    "uint_32 reason struct property."
    return self._reason

  @reason.setter
  def reason(self, value):
    self._reason = msgbuffers.validate_integer(
      'Disconnect.reason', value, 0, 4294967295)

  def __init__(self, reason=0):
    self.reason = reason

  @classmethod
  def unpack(cls, buffer):
    "Reads a new Disconnect from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('Disconnect.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new Disconnect from the given BinaryReader."
    _reason = reader.read('I')
    return cls(_reason)

  def pack(self):
    "Writes the current Disconnect, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current Disconnect to the given BinaryWriter."
    writer.write(self._reason, 'I')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._reason == other._reason
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._reason, 'I'))

  def __str__(self):
    return '{type}(reason={reason})'.format(
      type=type(self).__name__,
      reason=self._reason)

  def __repr__(self):
    return '{type}(reason={reason})'.format(
      type=type(self).__name__,
      reason=repr(self._reason))

Anki.Cozmo.BLE.Disconnect = Disconnect
del Disconnect


class ConnectionState(object):
  "Generated message-passing message."

  __slots__ = (
    '_state', # uint_32
  )

  @property
  def state(self):
    "uint_32 state struct property."
    return self._state

  @state.setter
  def state(self, value):
    self._state = msgbuffers.validate_integer(
      'ConnectionState.state', value, 0, 4294967295)

  def __init__(self, state=0):
    self.state = state

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ConnectionState from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ConnectionState.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ConnectionState from the given BinaryReader."
    _state = reader.read('I')
    return cls(_state)

  def pack(self):
    "Writes the current ConnectionState, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ConnectionState to the given BinaryWriter."
    writer.write(self._state, 'I')

  def __eq__(self, other):
    if type(self) is type(other):
      return self._state == other._state
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._state, 'I'))

  def __str__(self):
    return '{type}(state={state})'.format(
      type=type(self).__name__,
      state=self._state)

  def __repr__(self):
    return '{type}(state={state})'.format(
      type=type(self).__name__,
      state=repr(self._state))

Anki.Cozmo.BLE.ConnectionState = ConnectionState
del ConnectionState


class DataReceived(object):
  "Generated message-passing message."

  __slots__ = (
    '_frame', # Anki.Cozmo.BLE.Frame
  )

  @property
  def frame(self):
    "Anki.Cozmo.BLE.Frame frame struct property."
    return self._frame

  @frame.setter
  def frame(self, value):
    self._frame = msgbuffers.validate_object(
      'DataReceived.frame', value, Anki.Cozmo.BLE.Frame)

  def __init__(self, frame=Anki.Cozmo.BLE.Frame()):
    self.frame = frame

  @classmethod
  def unpack(cls, buffer):
    "Reads a new DataReceived from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('DataReceived.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new DataReceived from the given BinaryReader."
    _frame = reader.read_object(Anki.Cozmo.BLE.Frame.unpack_from)
    return cls(_frame)

  def pack(self):
    "Writes the current DataReceived, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current DataReceived to the given BinaryWriter."
    writer.write_object(self._frame)

  def __eq__(self, other):
    if type(self) is type(other):
      return self._frame == other._frame
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_object(self._frame))

  def __str__(self):
    return '{type}(frame={frame})'.format(
      type=type(self).__name__,
      frame=self._frame)

  def __repr__(self):
    return '{type}(frame={frame})'.format(
      type=type(self).__name__,
      frame=repr(self._frame))

Anki.Cozmo.BLE.DataReceived = DataReceived
del DataReceived


class SendData(object):
  "Generated message-passing message."

  __slots__ = (
    '_frame', # Anki.Cozmo.BLE.Frame
  )

  @property
  def frame(self):
    "Anki.Cozmo.BLE.Frame frame struct property."
    return self._frame

  @frame.setter
  def frame(self, value):
    self._frame = msgbuffers.validate_object(
      'SendData.frame', value, Anki.Cozmo.BLE.Frame)

  def __init__(self, frame=Anki.Cozmo.BLE.Frame()):
    self.frame = frame

  @classmethod
  def unpack(cls, buffer):
    "Reads a new SendData from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('SendData.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new SendData from the given BinaryReader."
    _frame = reader.read_object(Anki.Cozmo.BLE.Frame.unpack_from)
    return cls(_frame)

  def pack(self):
    "Writes the current SendData, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current SendData to the given BinaryWriter."
    writer.write_object(self._frame)

  def __eq__(self, other):
    if type(self) is type(other):
      return self._frame == other._frame
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_object(self._frame))

  def __str__(self):
    return '{type}(frame={frame})'.format(
      type=type(self).__name__,
      frame=self._frame)

  def __repr__(self):
    return '{type}(frame={frame})'.format(
      type=type(self).__name__,
      frame=repr(self._frame))

Anki.Cozmo.BLE.SendData = SendData
del SendData


