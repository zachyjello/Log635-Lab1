"""
Autogenerated python message buffer code.
Source: util/ankiLab/ankiLabDef.clad
Full command line: ../tools/message-buffers/emitters/Python_emitter.py -C ../lib/util/source/anki/clad -I ../lib/util/source/anki/clad -o ../generated/cladPython// util/ankiLab/ankiLabDef.clad
"""

from __future__ import absolute_import
from __future__ import print_function

def _modify_path():
  import inspect, os, sys
  search_paths = [
    '../..',
    '../../../../tools/message-buffers/support/python',
  ]
  currentpath = os.path.abspath(os.path.dirname(inspect.getfile(inspect.currentframe())))
  for search_path in search_paths:
    search_path = os.path.normpath(os.path.abspath(os.path.realpath(os.path.join(currentpath, search_path))))
    if search_path not in sys.path:
      sys.path.insert(0, search_path)
_modify_path()

import msgbuffers

Anki = msgbuffers.Namespace()
Anki.Util = msgbuffers.Namespace()
Anki.Util.AnkiLab = msgbuffers.Namespace()

class Metadata(object):
  "Generated message-passing structure."

  __slots__ = (
    '_project_id', # string[uint_8]
    '_version',    # uint_32
    '_revision',   # uint_32
  )

  @property
  def project_id(self):
    "string[uint_8] project_id struct property."
    return self._project_id

  @project_id.setter
  def project_id(self, value):
    self._project_id = msgbuffers.validate_string(
      'Metadata.project_id', value, 255)

  @property
  def version(self):
    "uint_32 version struct property."
    return self._version

  @version.setter
  def version(self, value):
    self._version = msgbuffers.validate_integer(
      'Metadata.version', value, 0, 4294967295)

  @property
  def revision(self):
    "uint_32 revision struct property."
    return self._revision

  @revision.setter
  def revision(self, value):
    self._revision = msgbuffers.validate_integer(
      'Metadata.revision', value, 0, 4294967295)

  def __init__(self, project_id='', version=0, revision=0):
    self.project_id = project_id
    self.version = version
    self.revision = revision

  @classmethod
  def unpack(cls, buffer):
    "Reads a new Metadata from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('Metadata.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new Metadata from the given BinaryReader."
    _project_id = reader.read_string('B')
    _version = reader.read('I')
    _revision = reader.read('I')
    return cls(_project_id, _version, _revision)

  def pack(self):
    "Writes the current Metadata, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current Metadata to the given BinaryWriter."
    writer.write_string(self._project_id, 'B')
    writer.write(self._version, 'I')
    writer.write(self._revision, 'I')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._project_id == other._project_id and
        self._version == other._version and
        self._revision == other._revision)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_string(self._project_id, 'B') +
      msgbuffers.size(self._version, 'I') +
      msgbuffers.size(self._revision, 'I'))

  def __str__(self):
    return '{type}(project_id={project_id}, version={version}, revision={revision})'.format(
      type=type(self).__name__,
      project_id=msgbuffers.shorten_string(self._project_id),
      version=self._version,
      revision=self._revision)

  def __repr__(self):
    return '{type}(project_id={project_id}, version={version}, revision={revision})'.format(
      type=type(self).__name__,
      project_id=repr(self._project_id),
      version=repr(self._version),
      revision=repr(self._revision))

Anki.Util.AnkiLab.Metadata = Metadata
del Metadata


class ExperimentVariation(object):
  "Generated message-passing structure."

  __slots__ = (
    '_key',          # string[uint_8]
    '_pop_frac_pct', # uint_8
  )

  @property
  def key(self):
    "string[uint_8] key struct property."
    return self._key

  @key.setter
  def key(self, value):
    self._key = msgbuffers.validate_string(
      'ExperimentVariation.key', value, 255)

  @property
  def pop_frac_pct(self):
    "uint_8 pop_frac_pct struct property."
    return self._pop_frac_pct

  @pop_frac_pct.setter
  def pop_frac_pct(self, value):
    self._pop_frac_pct = msgbuffers.validate_integer(
      'ExperimentVariation.pop_frac_pct', value, 0, 255)

  def __init__(self, key='', pop_frac_pct=0):
    self.key = key
    self.pop_frac_pct = pop_frac_pct

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ExperimentVariation from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ExperimentVariation.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ExperimentVariation from the given BinaryReader."
    _key = reader.read_string('B')
    _pop_frac_pct = reader.read('B')
    return cls(_key, _pop_frac_pct)

  def pack(self):
    "Writes the current ExperimentVariation, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ExperimentVariation to the given BinaryWriter."
    writer.write_string(self._key, 'B')
    writer.write(self._pop_frac_pct, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._key == other._key and
        self._pop_frac_pct == other._pop_frac_pct)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_string(self._key, 'B') +
      msgbuffers.size(self._pop_frac_pct, 'B'))

  def __str__(self):
    return '{type}(key={key}, pop_frac_pct={pop_frac_pct})'.format(
      type=type(self).__name__,
      key=msgbuffers.shorten_string(self._key),
      pop_frac_pct=self._pop_frac_pct)

  def __repr__(self):
    return '{type}(key={key}, pop_frac_pct={pop_frac_pct})'.format(
      type=type(self).__name__,
      key=repr(self._key),
      pop_frac_pct=repr(self._pop_frac_pct))

Anki.Util.AnkiLab.ExperimentVariation = ExperimentVariation
del ExperimentVariation


class VariantCondition(object):
  "Generated message-passing structure."

  __slots__ = (
    '_user_id',       # string[uint_8]
    '_variation_key', # string[uint_8]
  )

  @property
  def user_id(self):
    "string[uint_8] user_id struct property."
    return self._user_id

  @user_id.setter
  def user_id(self, value):
    self._user_id = msgbuffers.validate_string(
      'VariantCondition.user_id', value, 255)

  @property
  def variation_key(self):
    "string[uint_8] variation_key struct property."
    return self._variation_key

  @variation_key.setter
  def variation_key(self, value):
    self._variation_key = msgbuffers.validate_string(
      'VariantCondition.variation_key', value, 255)

  def __init__(self, user_id='', variation_key=''):
    self.user_id = user_id
    self.variation_key = variation_key

  @classmethod
  def unpack(cls, buffer):
    "Reads a new VariantCondition from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('VariantCondition.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new VariantCondition from the given BinaryReader."
    _user_id = reader.read_string('B')
    _variation_key = reader.read_string('B')
    return cls(_user_id, _variation_key)

  def pack(self):
    "Writes the current VariantCondition, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current VariantCondition to the given BinaryWriter."
    writer.write_string(self._user_id, 'B')
    writer.write_string(self._variation_key, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._user_id == other._user_id and
        self._variation_key == other._variation_key)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_string(self._user_id, 'B') +
      msgbuffers.size_string(self._variation_key, 'B'))

  def __str__(self):
    return '{type}(user_id={user_id}, variation_key={variation_key})'.format(
      type=type(self).__name__,
      user_id=msgbuffers.shorten_string(self._user_id),
      variation_key=msgbuffers.shorten_string(self._variation_key))

  def __repr__(self):
    return '{type}(user_id={user_id}, variation_key={variation_key})'.format(
      type=type(self).__name__,
      user_id=repr(self._user_id),
      variation_key=repr(self._variation_key))

Anki.Util.AnkiLab.VariantCondition = VariantCondition
del VariantCondition


class ActivationMode(object):
  "Automatically-generated uint_8 enumeration."
  manual    = 0
  automatic = 1

Anki.Util.AnkiLab.ActivationMode = ActivationMode
del ActivationMode


class Experiment(object):
  "Generated message-passing structure."

  __slots__ = (
    '_version',                 # uint_32
    '_key',                     # string[uint_8]
    '_activation_mode',         # Anki.Util.AnkiLab.ActivationMode
    '_start_time_utc_iso8601',  # string[uint_8]
    '_stop_time_utc_iso8601',   # string[uint_8]
    '_pause_time_utc_iso8601',  # string[uint_8]
    '_resume_time_utc_iso8601', # string[uint_8]
    '_pop_frac_pct',            # uint_8
    '_audience_tags',           # string[uint_8][uint_8]
    '_variations',              # ExperimentVariation[uint_8]
    '_forced_variations',       # VariantCondition[uint_8]
  )

  @property
  def version(self):
    "uint_32 version struct property."
    return self._version

  @version.setter
  def version(self, value):
    self._version = msgbuffers.validate_integer(
      'Experiment.version', value, 0, 4294967295)

  @property
  def key(self):
    "string[uint_8] key struct property."
    return self._key

  @key.setter
  def key(self, value):
    self._key = msgbuffers.validate_string(
      'Experiment.key', value, 255)

  @property
  def activation_mode(self):
    "Anki.Util.AnkiLab.ActivationMode activation_mode struct property."
    return self._activation_mode

  @activation_mode.setter
  def activation_mode(self, value):
    self._activation_mode = msgbuffers.validate_integer(
      'Experiment.activation_mode', value, 0, 255)

  @property
  def start_time_utc_iso8601(self):
    "string[uint_8] start_time_utc_iso8601 struct property."
    return self._start_time_utc_iso8601

  @start_time_utc_iso8601.setter
  def start_time_utc_iso8601(self, value):
    self._start_time_utc_iso8601 = msgbuffers.validate_string(
      'Experiment.start_time_utc_iso8601', value, 255)

  @property
  def stop_time_utc_iso8601(self):
    "string[uint_8] stop_time_utc_iso8601 struct property."
    return self._stop_time_utc_iso8601

  @stop_time_utc_iso8601.setter
  def stop_time_utc_iso8601(self, value):
    self._stop_time_utc_iso8601 = msgbuffers.validate_string(
      'Experiment.stop_time_utc_iso8601', value, 255)

  @property
  def pause_time_utc_iso8601(self):
    "string[uint_8] pause_time_utc_iso8601 struct property."
    return self._pause_time_utc_iso8601

  @pause_time_utc_iso8601.setter
  def pause_time_utc_iso8601(self, value):
    self._pause_time_utc_iso8601 = msgbuffers.validate_string(
      'Experiment.pause_time_utc_iso8601', value, 255)

  @property
  def resume_time_utc_iso8601(self):
    "string[uint_8] resume_time_utc_iso8601 struct property."
    return self._resume_time_utc_iso8601

  @resume_time_utc_iso8601.setter
  def resume_time_utc_iso8601(self, value):
    self._resume_time_utc_iso8601 = msgbuffers.validate_string(
      'Experiment.resume_time_utc_iso8601', value, 255)

  @property
  def pop_frac_pct(self):
    "uint_8 pop_frac_pct struct property."
    return self._pop_frac_pct

  @pop_frac_pct.setter
  def pop_frac_pct(self, value):
    self._pop_frac_pct = msgbuffers.validate_integer(
      'Experiment.pop_frac_pct', value, 0, 255)

  @property
  def audience_tags(self):
    "string[uint_8][uint_8] audience_tags struct property."
    return self._audience_tags

  @audience_tags.setter
  def audience_tags(self, value):
    self._audience_tags = msgbuffers.validate_varray(
      'Experiment.audience_tags', value, 255,
      lambda name, value_inner: msgbuffers.validate_string(
        name, value_inner, 255))

  @property
  def variations(self):
    "ExperimentVariation[uint_8] variations struct property."
    return self._variations

  @variations.setter
  def variations(self, value):
    self._variations = msgbuffers.validate_varray(
      'Experiment.variations', value, 255,
      lambda name, value_inner: msgbuffers.validate_object(
        name, value_inner, Anki.Util.AnkiLab.ExperimentVariation))

  @property
  def forced_variations(self):
    "VariantCondition[uint_8] forced_variations struct property."
    return self._forced_variations

  @forced_variations.setter
  def forced_variations(self, value):
    self._forced_variations = msgbuffers.validate_varray(
      'Experiment.forced_variations', value, 255,
      lambda name, value_inner: msgbuffers.validate_object(
        name, value_inner, Anki.Util.AnkiLab.VariantCondition))

  def __init__(self, version=0, key='', activation_mode=Anki.Util.AnkiLab.ActivationMode.manual, start_time_utc_iso8601='', stop_time_utc_iso8601='', pause_time_utc_iso8601='', resume_time_utc_iso8601='', pop_frac_pct=0, audience_tags=(), variations=(), forced_variations=()):
    self.version = version
    self.key = key
    self.activation_mode = activation_mode
    self.start_time_utc_iso8601 = start_time_utc_iso8601
    self.stop_time_utc_iso8601 = stop_time_utc_iso8601
    self.pause_time_utc_iso8601 = pause_time_utc_iso8601
    self.resume_time_utc_iso8601 = resume_time_utc_iso8601
    self.pop_frac_pct = pop_frac_pct
    self.audience_tags = audience_tags
    self.variations = variations
    self.forced_variations = forced_variations

  @classmethod
  def unpack(cls, buffer):
    "Reads a new Experiment from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('Experiment.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new Experiment from the given BinaryReader."
    _version = reader.read('I')
    _key = reader.read_string('B')
    _activation_mode = reader.read('B')
    _start_time_utc_iso8601 = reader.read_string('B')
    _stop_time_utc_iso8601 = reader.read_string('B')
    _pause_time_utc_iso8601 = reader.read_string('B')
    _resume_time_utc_iso8601 = reader.read_string('B')
    _pop_frac_pct = reader.read('B')
    _audience_tags = reader.read_string_varray('B', 'B')
    _variations = reader.read_object_varray(Anki.Util.AnkiLab.ExperimentVariation.unpack_from, 'B')
    _forced_variations = reader.read_object_varray(Anki.Util.AnkiLab.VariantCondition.unpack_from, 'B')
    return cls(_version, _key, _activation_mode, _start_time_utc_iso8601, _stop_time_utc_iso8601, _pause_time_utc_iso8601, _resume_time_utc_iso8601, _pop_frac_pct, _audience_tags, _variations, _forced_variations)

  def pack(self):
    "Writes the current Experiment, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current Experiment to the given BinaryWriter."
    writer.write(self._version, 'I')
    writer.write_string(self._key, 'B')
    writer.write(self._activation_mode, 'B')
    writer.write_string(self._start_time_utc_iso8601, 'B')
    writer.write_string(self._stop_time_utc_iso8601, 'B')
    writer.write_string(self._pause_time_utc_iso8601, 'B')
    writer.write_string(self._resume_time_utc_iso8601, 'B')
    writer.write(self._pop_frac_pct, 'B')
    writer.write_string_varray(self._audience_tags, 'B', 'B')
    writer.write_object_varray(self._variations, 'B')
    writer.write_object_varray(self._forced_variations, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._version == other._version and
        self._key == other._key and
        self._activation_mode == other._activation_mode and
        self._start_time_utc_iso8601 == other._start_time_utc_iso8601 and
        self._stop_time_utc_iso8601 == other._stop_time_utc_iso8601 and
        self._pause_time_utc_iso8601 == other._pause_time_utc_iso8601 and
        self._resume_time_utc_iso8601 == other._resume_time_utc_iso8601 and
        self._pop_frac_pct == other._pop_frac_pct and
        self._audience_tags == other._audience_tags and
        self._variations == other._variations and
        self._forced_variations == other._forced_variations)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._version, 'I') +
      msgbuffers.size_string(self._key, 'B') +
      msgbuffers.size(self._activation_mode, 'B') +
      msgbuffers.size_string(self._start_time_utc_iso8601, 'B') +
      msgbuffers.size_string(self._stop_time_utc_iso8601, 'B') +
      msgbuffers.size_string(self._pause_time_utc_iso8601, 'B') +
      msgbuffers.size_string(self._resume_time_utc_iso8601, 'B') +
      msgbuffers.size(self._pop_frac_pct, 'B') +
      msgbuffers.size_string_varray(self._audience_tags, 'B', 'B') +
      msgbuffers.size_object_varray(self._variations, 'B') +
      msgbuffers.size_object_varray(self._forced_variations, 'B'))

  def __str__(self):
    return '{type}(version={version}, key={key}, activation_mode={activation_mode}, start_time_utc_iso8601={start_time_utc_iso8601}, stop_time_utc_iso8601={stop_time_utc_iso8601}, pause_time_utc_iso8601={pause_time_utc_iso8601}, resume_time_utc_iso8601={resume_time_utc_iso8601}, pop_frac_pct={pop_frac_pct}, audience_tags={audience_tags}, variations={variations}, forced_variations={forced_variations})'.format(
      type=type(self).__name__,
      version=self._version,
      key=msgbuffers.shorten_string(self._key),
      activation_mode=self._activation_mode,
      start_time_utc_iso8601=msgbuffers.shorten_string(self._start_time_utc_iso8601),
      stop_time_utc_iso8601=msgbuffers.shorten_string(self._stop_time_utc_iso8601),
      pause_time_utc_iso8601=msgbuffers.shorten_string(self._pause_time_utc_iso8601),
      resume_time_utc_iso8601=msgbuffers.shorten_string(self._resume_time_utc_iso8601),
      pop_frac_pct=self._pop_frac_pct,
      audience_tags=msgbuffers.shorten_sequence(self._audience_tags, msgbuffers.shorten_string),
      variations=msgbuffers.shorten_sequence(self._variations),
      forced_variations=msgbuffers.shorten_sequence(self._forced_variations))

  def __repr__(self):
    return '{type}(version={version}, key={key}, activation_mode={activation_mode}, start_time_utc_iso8601={start_time_utc_iso8601}, stop_time_utc_iso8601={stop_time_utc_iso8601}, pause_time_utc_iso8601={pause_time_utc_iso8601}, resume_time_utc_iso8601={resume_time_utc_iso8601}, pop_frac_pct={pop_frac_pct}, audience_tags={audience_tags}, variations={variations}, forced_variations={forced_variations})'.format(
      type=type(self).__name__,
      version=repr(self._version),
      key=repr(self._key),
      activation_mode=repr(self._activation_mode),
      start_time_utc_iso8601=repr(self._start_time_utc_iso8601),
      stop_time_utc_iso8601=repr(self._stop_time_utc_iso8601),
      pause_time_utc_iso8601=repr(self._pause_time_utc_iso8601),
      resume_time_utc_iso8601=repr(self._resume_time_utc_iso8601),
      pop_frac_pct=repr(self._pop_frac_pct),
      audience_tags=repr(self._audience_tags),
      variations=repr(self._variations),
      forced_variations=repr(self._forced_variations))

Anki.Util.AnkiLab.Experiment = Experiment
del Experiment


class AnkiLabDef(object):
  "Generated message-passing structure."

  __slots__ = (
    '_meta',        # Anki.Util.AnkiLab.Metadata
    '_experiments', # Experiment[uint_8]
  )

  @property
  def meta(self):
    "Anki.Util.AnkiLab.Metadata meta struct property."
    return self._meta

  @meta.setter
  def meta(self, value):
    self._meta = msgbuffers.validate_object(
      'AnkiLabDef.meta', value, Anki.Util.AnkiLab.Metadata)

  @property
  def experiments(self):
    "Experiment[uint_8] experiments struct property."
    return self._experiments

  @experiments.setter
  def experiments(self, value):
    self._experiments = msgbuffers.validate_varray(
      'AnkiLabDef.experiments', value, 255,
      lambda name, value_inner: msgbuffers.validate_object(
        name, value_inner, Anki.Util.AnkiLab.Experiment))

  def __init__(self, meta=Anki.Util.AnkiLab.Metadata(), experiments=()):
    self.meta = meta
    self.experiments = experiments

  @classmethod
  def unpack(cls, buffer):
    "Reads a new AnkiLabDef from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('AnkiLabDef.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new AnkiLabDef from the given BinaryReader."
    _meta = reader.read_object(Anki.Util.AnkiLab.Metadata.unpack_from)
    _experiments = reader.read_object_varray(Anki.Util.AnkiLab.Experiment.unpack_from, 'B')
    return cls(_meta, _experiments)

  def pack(self):
    "Writes the current AnkiLabDef, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current AnkiLabDef to the given BinaryWriter."
    writer.write_object(self._meta)
    writer.write_object_varray(self._experiments, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._meta == other._meta and
        self._experiments == other._experiments)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_object(self._meta) +
      msgbuffers.size_object_varray(self._experiments, 'B'))

  def __str__(self):
    return '{type}(meta={meta}, experiments={experiments})'.format(
      type=type(self).__name__,
      meta=self._meta,
      experiments=msgbuffers.shorten_sequence(self._experiments))

  def __repr__(self):
    return '{type}(meta={meta}, experiments={experiments})'.format(
      type=type(self).__name__,
      meta=repr(self._meta),
      experiments=repr(self._experiments))

Anki.Util.AnkiLab.AnkiLabDef = AnkiLabDef
del AnkiLabDef


class AssignmentDef(object):
  "Generated message-passing structure."

  __slots__ = (
    '_experiment_key', # string[uint_8]
    '_user_id',        # string[uint_8]
    '_variation_key',  # string[uint_8]
  )

  @property
  def experiment_key(self):
    "string[uint_8] experiment_key struct property."
    return self._experiment_key

  @experiment_key.setter
  def experiment_key(self, value):
    self._experiment_key = msgbuffers.validate_string(
      'AssignmentDef.experiment_key', value, 255)

  @property
  def user_id(self):
    "string[uint_8] user_id struct property."
    return self._user_id

  @user_id.setter
  def user_id(self, value):
    self._user_id = msgbuffers.validate_string(
      'AssignmentDef.user_id', value, 255)

  @property
  def variation_key(self):
    "string[uint_8] variation_key struct property."
    return self._variation_key

  @variation_key.setter
  def variation_key(self, value):
    self._variation_key = msgbuffers.validate_string(
      'AssignmentDef.variation_key', value, 255)

  def __init__(self, experiment_key='', user_id='', variation_key=''):
    self.experiment_key = experiment_key
    self.user_id = user_id
    self.variation_key = variation_key

  @classmethod
  def unpack(cls, buffer):
    "Reads a new AssignmentDef from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('AssignmentDef.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new AssignmentDef from the given BinaryReader."
    _experiment_key = reader.read_string('B')
    _user_id = reader.read_string('B')
    _variation_key = reader.read_string('B')
    return cls(_experiment_key, _user_id, _variation_key)

  def pack(self):
    "Writes the current AssignmentDef, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current AssignmentDef to the given BinaryWriter."
    writer.write_string(self._experiment_key, 'B')
    writer.write_string(self._user_id, 'B')
    writer.write_string(self._variation_key, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._experiment_key == other._experiment_key and
        self._user_id == other._user_id and
        self._variation_key == other._variation_key)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_string(self._experiment_key, 'B') +
      msgbuffers.size_string(self._user_id, 'B') +
      msgbuffers.size_string(self._variation_key, 'B'))

  def __str__(self):
    return '{type}(experiment_key={experiment_key}, user_id={user_id}, variation_key={variation_key})'.format(
      type=type(self).__name__,
      experiment_key=msgbuffers.shorten_string(self._experiment_key),
      user_id=msgbuffers.shorten_string(self._user_id),
      variation_key=msgbuffers.shorten_string(self._variation_key))

  def __repr__(self):
    return '{type}(experiment_key={experiment_key}, user_id={user_id}, variation_key={variation_key})'.format(
      type=type(self).__name__,
      experiment_key=repr(self._experiment_key),
      user_id=repr(self._user_id),
      variation_key=repr(self._variation_key))

Anki.Util.AnkiLab.AssignmentDef = AssignmentDef
del AssignmentDef


class AssignmentStatus(object):
  "Automatically-generated uint_8 enumeration."
  Invalid              = 0
  ExperimentNotFound   = 1
  VariantNotFound      = 2
  ExperimentNotRunning = 3
  AudienceMismatch     = 4
  Unassigned           = 5
  Assigned             = 6
  OverrideAssigned     = 7
  ForceAssigned        = 8

Anki.Util.AnkiLab.AssignmentStatus = AssignmentStatus
del AssignmentStatus


class ActivateExperimentRequest(object):
  "Generated message-passing message."

  __slots__ = (
    '_experiment_key', # string[uint_8]
    '_user_id',        # string[uint_8]
  )

  @property
  def experiment_key(self):
    "string[uint_8] experiment_key struct property."
    return self._experiment_key

  @experiment_key.setter
  def experiment_key(self, value):
    self._experiment_key = msgbuffers.validate_string(
      'ActivateExperimentRequest.experiment_key', value, 255)

  @property
  def user_id(self):
    "string[uint_8] user_id struct property."
    return self._user_id

  @user_id.setter
  def user_id(self, value):
    self._user_id = msgbuffers.validate_string(
      'ActivateExperimentRequest.user_id', value, 255)

  def __init__(self, experiment_key='', user_id=''):
    self.experiment_key = experiment_key
    self.user_id = user_id

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ActivateExperimentRequest from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ActivateExperimentRequest.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ActivateExperimentRequest from the given BinaryReader."
    _experiment_key = reader.read_string('B')
    _user_id = reader.read_string('B')
    return cls(_experiment_key, _user_id)

  def pack(self):
    "Writes the current ActivateExperimentRequest, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ActivateExperimentRequest to the given BinaryWriter."
    writer.write_string(self._experiment_key, 'B')
    writer.write_string(self._user_id, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._experiment_key == other._experiment_key and
        self._user_id == other._user_id)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size_string(self._experiment_key, 'B') +
      msgbuffers.size_string(self._user_id, 'B'))

  def __str__(self):
    return '{type}(experiment_key={experiment_key}, user_id={user_id})'.format(
      type=type(self).__name__,
      experiment_key=msgbuffers.shorten_string(self._experiment_key),
      user_id=msgbuffers.shorten_string(self._user_id))

  def __repr__(self):
    return '{type}(experiment_key={experiment_key}, user_id={user_id})'.format(
      type=type(self).__name__,
      experiment_key=repr(self._experiment_key),
      user_id=repr(self._user_id))

Anki.Util.AnkiLab.ActivateExperimentRequest = ActivateExperimentRequest
del ActivateExperimentRequest


class ActivateExperimentResponse(object):
  "Generated message-passing message."

  __slots__ = (
    '_status',        # Anki.Util.AnkiLab.AssignmentStatus
    '_variation_key', # string[uint_8]
  )

  @property
  def status(self):
    "Anki.Util.AnkiLab.AssignmentStatus status struct property."
    return self._status

  @status.setter
  def status(self, value):
    self._status = msgbuffers.validate_integer(
      'ActivateExperimentResponse.status', value, 0, 255)

  @property
  def variation_key(self):
    "string[uint_8] variation_key struct property."
    return self._variation_key

  @variation_key.setter
  def variation_key(self, value):
    self._variation_key = msgbuffers.validate_string(
      'ActivateExperimentResponse.variation_key', value, 255)

  def __init__(self, status=Anki.Util.AnkiLab.AssignmentStatus.Invalid, variation_key=''):
    self.status = status
    self.variation_key = variation_key

  @classmethod
  def unpack(cls, buffer):
    "Reads a new ActivateExperimentResponse from the given buffer."
    reader = msgbuffers.BinaryReader(buffer)
    value = cls.unpack_from(reader)
    if reader.tell() != len(reader):
      raise msgbuffers.ReadError(
        ('ActivateExperimentResponse.unpack received a buffer of length {length}, ' +
        'but only {position} bytes were read.').format(
        length=len(reader), position=reader.tell()))
    return value

  @classmethod
  def unpack_from(cls, reader):
    "Reads a new ActivateExperimentResponse from the given BinaryReader."
    _status = reader.read('B')
    _variation_key = reader.read_string('B')
    return cls(_status, _variation_key)

  def pack(self):
    "Writes the current ActivateExperimentResponse, returning bytes."
    writer = msgbuffers.BinaryWriter()
    self.pack_to(writer)
    return writer.dumps()

  def pack_to(self, writer):
    "Writes the current ActivateExperimentResponse to the given BinaryWriter."
    writer.write(self._status, 'B')
    writer.write_string(self._variation_key, 'B')

  def __eq__(self, other):
    if type(self) is type(other):
      return (self._status == other._status and
        self._variation_key == other._variation_key)
    else:
      return NotImplemented

  def __ne__(self, other):
    if type(self) is type(other):
      return not self.__eq__(other)
    else:
      return NotImplemented

  def __len__(self):
    return (msgbuffers.size(self._status, 'B') +
      msgbuffers.size_string(self._variation_key, 'B'))

  def __str__(self):
    return '{type}(status={status}, variation_key={variation_key})'.format(
      type=type(self).__name__,
      status=self._status,
      variation_key=msgbuffers.shorten_string(self._variation_key))

  def __repr__(self):
    return '{type}(status={status}, variation_key={variation_key})'.format(
      type=type(self).__name__,
      status=repr(self._status),
      variation_key=repr(self._variation_key))

Anki.Util.AnkiLab.ActivateExperimentResponse = ActivateExperimentResponse
del ActivateExperimentResponse


